import { RefObject, ReactNode } from 'react';
import { Constrain, ObjectFromUnion, FluidValue, ObjectType, OneOrMore, Animatable, Merge, EasingFunction, UnknownPartial, UnknownProps as UnknownProps$1, FluidProps, Remap, Indexable as Indexable$1, Any as Any$1, Falsy as Falsy$1 } from '@react-spring/shared';
export { Animatable, Globals, createInterpolator, isFluidValue, makeFluidValue } from '@react-spring/shared';
import { AnimationValue, OnChange, AnimatedValue, Into } from '@react-spring/animated';
export { AnimationValue, Into, isAnimationValue } from '@react-spring/animated';
import { Indexable, Falsy, NoInfer, OneOrMore as OneOrMore$1 } from '@react-spring/shared/types/common';
export { UnknownProps } from '@react-spring/shared/types/common';
import { Any } from '@react-spring/shared';
import { FluidValue as FluidValue$1, InterpolatorFn, OneOrMore as OneOrMore$2, InterpolatorConfig, Animatable as Animatable$1, Constrain as Constrain$1, ExtrapolateType, FrameRequestCallback } from '@react-spring/shared/types';
export * from '@react-spring/shared/types/animated';
export * from '@react-spring/shared/types/interpolation';

/** Map the `T` object type and replace any properties that cannot be assigned to `U` with `never` */
declare type Valid<T extends object, U extends object> = {
    [P in keyof T & keyof U]: T[P] extends U[P] ? U[P] : never;
};
/** The phases of a `useTransition` item */
declare type TransitionPhase = 'initial' | 'enter' | 'update' | 'leave';
/**
 * Pick the properties of these object props...
 *
 *     "to", "from", "initial", "enter", "update", "leave"
 *
 * ...as well as any forward props.
 */
declare type PickAnimated<Props extends object, Fwd = true> = unknown & ObjectFromUnion<FromValues<Props> | (TransitionPhase & keyof Props extends never ? ToValues<Props, Fwd> : TransitionValues<Props>)>;
/** Unwrap any `FluidValue` object types */
declare type RawValues<T extends object> = {
    [P in keyof T]: T[P] extends FluidValue<infer U> ? U : T[P];
};
/**
 * Pick the values of the `to` prop. Forward props are *not* included.
 */
declare type ToValues<Props extends object, AndForward = true> = unknown & (AndForward extends true ? ForwardProps<Props> : unknown) & (Props extends {
    to?: infer To;
} ? To extends Function ? unknown : To extends ReadonlyArray<infer T> ? T extends object ? {
    [P in keyof Props]: PickAnimated<T, AndForward>;
}[keyof Props] : unknown : ForwardProps<ObjectType<To>> : unknown);
/**
 * Pick the values of the `from` prop.
 */
declare type FromValues<Props extends object> = ForwardProps<Props extends {
    from?: infer From;
} ? ObjectType<From> : object>;
/**
 * Extract a union of animated values from a set of `useTransition` props.
 */
declare type TransitionValues<Props extends object> = unknown & ForwardProps<ObjectFromUnion<Constrain<ObjectType<Props[TransitionPhase & keyof Props] extends infer T ? T extends ReadonlyArray<infer Element> ? Element : T extends ((...args: any[]) => infer Return) ? Return extends ReadonlyArray<infer ReturnElement> ? ReturnElement : Return : T : never>, {}>>>;
/**
 * Extract the custom props that are treated like `to` values
 */
declare type ForwardProps<T extends object> = RawValues<Omit<Constrain<T, {}>, keyof ReservedProps>>;
/**
 * Property names that are reserved for animation config
 */
interface ReservedProps {
    children?: any;
    config?: any;
    from?: any;
    to?: any;
    ref?: any;
    reset?: any;
    cancel?: any;
    reverse?: any;
    immediate?: any;
    default?: any;
    delay?: any;
    lazy?: any;
    items?: any;
    trail?: any;
    sort?: any;
    expires?: any;
    initial?: any;
    enter?: any;
    leave?: any;
    update?: any;
    onAnimate?: any;
    onStart?: any;
    onRest?: any;
    onChange?: any;
    onFrame?: any;
}

declare type MatchProp<P extends string = string> = boolean | OneOrMore<P> | ((key: P) => boolean);
/** These props can have default values */
declare const DEFAULT_PROPS: readonly ["config", "immediate", "onAnimate", "onStart", "onChange", "onRest"];

/** Default props for a `SpringValue` object */
declare type DefaultProps<T = unknown> = {
    [D in (typeof DEFAULT_PROPS)[number]]?: PendingProps<T>[D];
};
/** Pending props for a `SpringValue` object */
declare type PendingProps<T = unknown> = unknown & SpringProps<T> & AnimationEvents<T>;
declare type Phase = typeof DISPOSED | typeof CREATED | typeof IDLE | typeof PAUSED | typeof ACTIVE;
/** The spring cannot be animated */
declare const DISPOSED = "DISPOSED";
/** The spring has not animated yet */
declare const CREATED = "CREATED";
/** The spring has animated before */
declare const IDLE = "IDLE";
/** The spring is frozen in time */
declare const PAUSED = "PAUSED";
/** The spring is animating */
declare const ACTIVE = "ACTIVE";
/** An opaque animatable value */
declare class SpringValue<T = any> extends AnimationValue<T> {
    /** The animation state */
    animation: Animation<T>;
    /** The queue of pending props */
    queue?: PendingProps<T>[];
    /** @internal The animated node. Do not touch! */
    node: AnimationValue<T>['node'];
    /** The lifecycle phase of this spring */
    protected _phase: string;
    /** The state for `runAsync` calls */
    protected _state: RunAsyncState<T>;
    /** The last time each prop changed */
    protected _timestamps: Indexable<number>;
    /** Some props have customizable default values */
    protected _defaultProps: PendingProps<T>;
    /** Cancel any update from before this timestamp */
    protected _lastAsyncId: number;
    constructor(key?: string);
    readonly idle: boolean;
    /** Check the current phase */
    is(phase: Phase): boolean;
    /** Set the current value, while stopping the current animation */
    set(value: T | FluidValue<T>): this;
    /**
     * Freeze the active animation in time.
     * This does nothing when not animating.
     *
     * Call `start` to unpause.
     */
    pause(): void;
    /**
     * Skip to the end of the current animation.
     *
     * All `onRest` callbacks are passed `{finished: true}`
     */
    finish(to?: T | FluidValue<T>): this;
    /** Push props into the pending queue. */
    update(props: PendingProps<T>): this;
    /**
     * Update this value's animation using the queue of pending props,
     * and unpause the current animation (if one is frozen).
     *
     * When arguments are passed, a new animation is created, and the
     * queued animations are left alone.
     */
    start(): AsyncResult<T>;
    start(props: PendingProps<T>): AsyncResult<T>;
    start(to: Animatable<T>, props?: PendingProps<T>): AsyncResult<T>;
    /**
     * Stop the current animation, and cancel any delayed updates.
     */
    stop(): this;
    /** Restart the animation. */
    reset(): void;
    /** Prevent future animations, and stop the current animation */
    dispose(): void;
    /** Observe value changes. To stop observing, call the returned function. */
    onChange(fn: OnChange<T>): () => void;
    /** @internal */
    onParentChange(value: any, idle: boolean): void;
    /** @internal Called by the frameloop */
    onFrame(idle: boolean, changed: boolean): void;
    /**
     * @internal
     * Analyze the given `value` to determine which data type is being animated.
     * Then, create an `Animated` node for that data type and make it our `node`.
     */
    setNodeWithValue(value: any): void;
    /**
     * @internal
     * Analyze the given `props` to determine which data type is being animated.
     * Then, create an `Animated` node for that data type and make it our `node`.
     * If we already have a `node`, do nothing but return the `{from, to}` range.
     */
    setNodeWithProps(props: PendingProps<T>): AnimationRange<T>;
    /** Return the `Animated` node constructor for a given value */
    protected _getNodeType(value: T | FluidValue<T>): AnimatedType<T>;
    /** Pluck the `to` and `from` props */
    protected _getRange(props: PendingProps<T>): AnimationRange<T>;
    /** Update this value's animation using the given props. */
    protected _animate(props: PendingProps<T>): AsyncResult<T>;
    /** Update the internal `animation` object */
    protected _update({ to, from }: AnimationRange<T>, props: RunAsyncProps<T>, timestamp: number, resolve: OnRest<T>): void;
    /** Update the `animation.to` value, which might be a `FluidValue` */
    protected _to(value: T | FluidValue<T>): void;
    /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */
    protected _set(value: T | FluidValue<T>): boolean;
    /** Notify change observers */
    protected _onChange(value: T, idle?: boolean): void;
    protected _onPriorityChange(priority: number): void;
    /** Reset our node, and the nodes of every descendant spring */
    protected _reset(goal?: T): void;
    /** Enter the frameloop */
    protected _start(): void;
    /** Exit the frameloop and notify `onRest` listeners */
    protected _stop(finished?: boolean): void;
}

declare type AsyncResult<T = any> = Promise<AnimationResult<T>>;
declare type RunAsyncProps<T = any> = unknown & Merge<PendingProps<T>, {
    asyncId: number;
    cancel: boolean;
    reset: boolean;
    onAnimate?: (props: RunAsyncProps<T>, spring: SpringValue<T>) => void;
}>;
interface RunAsyncState<T> {
    /** The spring name */
    key?: string;
    /** The async function or array of spring props */
    asyncTo?: AsyncTo<T>;
    /** Resolves when the current `asyncTo` finishes or gets cancelled. */
    promise?: AsyncResult<T>;
    /** Call this to unpause the current `asyncTo` function or array. */
    unpause?: () => void;
    /** The last time we saw a matching `cancel` prop. */
    cancelId?: number;
}

declare type AnimatedType<T> = Function & {
    create: (from: any, goal?: any) => AnimationValue<T>['node'];
};
declare type AnimationRange<T> = {
    to: T | FluidValue<T> | undefined;
    from: T | FluidValue<T> | undefined;
};
/** Called before the given props are applied */
declare type OnAnimate<T = unknown> = (props: RunAsyncProps<T>, spring: SpringValue<T>) => void;
/** Called before the animation is added to the frameloop */
declare type OnStart<T = unknown> = (spring: SpringValue<T>) => void;
/** Called once the animation comes to a halt */
declare type OnRest<T = unknown> = (result: AnimationResult<T>) => void;
/** The object passed to `onRest` props */
declare type AnimationResult<T = any> = Readonly<{
    value: T;
    spring?: SpringValue<T>;
    /** When falsy, the animation did not reach its end value. */
    finished?: boolean;
    /** When true, the animation was cancelled before it could finish. */
    cancelled?: boolean;
}>;
interface AnimationConfig {
    /** @internal */
    w0: number;
    /**
     * Higher mass means more friction is required to slow down.
     *
     * Defaults to 1, which works fine most of the time.
     */
    mass: number;
    /**
     * With higher tension, the spring will resist bouncing and try harder to stop at its end value.
     *
     * When tension is zero, no animation occurs.
     */
    tension: number;
    /**
     * The natural frequency (in seconds), which dictates the number of bounces
     * per second when no damping exists.
     *
     * When defined, `tension` is derived from this, and `friction` is derived
     * from `tension` and `damping`.
     */
    frequency?: number;
    /**
     * The damping ratio, which dictates how the spring slows down.
     *
     * Set to `0` to never slow down. Set to `1` to slow down without bouncing.
     * Between `0` and `1` is for you to explore.
     *
     * Defaults to `1` when `frequency` is defined.
     */
    damping?: number;
    /**
     * The damping ratio coefficient, or just the damping ratio when `speed` is defined.
     *
     * When `speed` is defined, this value should be between 0 and 1.
     *
     * Higher friction means the spring will slow down faster.
     */
    friction: number;
    /**
     * The initial velocity of one or more values.
     */
    velocity: number | number[];
    /**
     * The smallest velocity before the animation is considered "not moving".
     *
     * When undefined, `precision` is used instead.
     */
    restVelocity?: number;
    /**
     * The smallest distance from a value before that distance is essentially zero.
     *
     * This helps in deciding when a spring is "at rest". The spring must be within
     * this distance from its final value, and its velocity must be lower than this
     * value too (unless `restVelocity` is defined).
     */
    precision?: number;
    /**
     * For `duration` animations only. Note: The `duration` is not affected
     * by this property.
     *
     * Defaults to `0`, which means "start from the beginning".
     *
     * Setting to `1+` makes an immediate animation.
     *
     * Setting to `0.5` means "start from the middle of the easing function".
     *
     * Any number `>= 0` and `<= 1` makes sense here.
     */
    progress: number;
    /**
     * Animation length in number of milliseconds.
     */
    duration?: number;
    /**
     * The animation curve.
     */
    easing: EasingFunction;
    /**
     * Avoid overshooting by ending abruptly at the goal value.
     */
    clamp?: boolean;
    /**
     * When above zero, the spring will bounce instead of overshooting when
     * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`
     * whenever its current value equals or exceeds its goal. For example,
     * setting `bounce` to `0.5` chops the velocity in half on each bounce,
     * in addition to any friction.
     */
    bounce?: number;
    /**
     * "Decay animations" decelerate without an explicit goal value.
     * Useful for scrolling animations.
     *
     * Use `true` for the default exponential decay factor (`0.998`).
     *
     * When a `number` between `0` and `1` is given, a lower number makes the
     * animation slow down faster. And setting to `1` would make an unending
     * animation.
     */
    decay?: boolean | number;
    /**
     * While animating, round to the nearest multiple of this number.
     * The `from` and `to` values are never rounded, as well as any value
     * passed to the `set` method of an animated value.
     */
    round?: number;
}
/** An animation being executed by the frameloop */
interface Animation<T = unknown> {
    changed: boolean;
    value: SpringValue<T>;
    values: readonly AnimatedValue[];
    to: T | FluidValue<T>;
    toValues: readonly number[] | null;
    from: T | FluidValue<T>;
    fromValues: readonly number[];
    config: AnimationConfig;
    reverse?: boolean;
    immediate: boolean;
    onStart?: OnStart<T>;
    onChange?: OnChange<T>;
    onRest?: Array<OnRest<T>>;
}
/** `SpringProps` without `to` or `from` */
interface AnimationProps<P extends string = string> {
    /**
     * Configure the spring behavior for each key.
     */
    config?: SpringConfig | ((key: P) => SpringConfig);
    /**
     * Milliseconds to wait before applying the other props.
     */
    delay?: number | ((key: P) => number);
    /**
     * When true, props jump to their goal values instead of animating.
     */
    immediate?: MatchProp<P>;
    /**
     * Cancel all animations by using `true`, or some animations by using a key
     * or an array of keys.
     */
    cancel?: MatchProp<P>;
    /**
     * Start the next animations at their values in the `from` prop.
     */
    reset?: MatchProp<P>;
    /**
     * Swap the `to` and `from` props.
     */
    reverse?: boolean;
    /**
     * Override the default props with this update.
     */
    default?: boolean;
}
/**
 * The event props of a `SpringValue` animation.
 *
 * The `T` parameter can be a set of animated properties (as an object type)
 * or a primitive type for a single animated value.
 */
declare type AnimationEvents<T = unknown> = {
    /**
     * Called when a controller is told to animate
     */
    onAnimate?: OnAnimate<T>;
    /**
     * Called when an animation moves for the first time
     */
    onStart?: OnStart<T>;
    /**
     * Called when all animations come to a stand-still
     */
    onRest?: OnRest<T>;
    /**
     * Called when a key/value pair is changed
     */
    onChange?: OnChange<T>;
};

/** A callback that receives the changed values for each frame. */
declare type OnFrame<State extends Indexable> = (frame: UnknownPartial<State>) => void;
declare type ControllerProps<State extends Indexable = UnknownProps$1> = {
    /**
     * Called on every frame when animations are active
     */
    onFrame?: OnFrame<State>;
} & SpringProps<State> & AnimationEvents<unknown> & UnknownPartial<FluidProps<State>>;
/** The props that are cached by `Controller` objects */
interface CachedProps<State extends Indexable> extends RunAsyncState<State> {
    onFrame?: OnFrame<State>;
}
/** An update that hasn't been applied yet */
declare type PendingProps$1<State extends Indexable> = ControllerProps<State> & {
    keys: string[];
};
/** Default props for the `Controller` class */
declare type DefaultProps$1<State extends Indexable> = {
    onFrame?: OnFrame<State>;
};
declare class Controller<State extends Indexable = UnknownProps$1> {
    readonly id: number;
    /** The values that changed in the last animation frame */
    frame: UnknownPartial<State>;
    /** Fallback values for undefined props */
    defaultProps: DefaultProps$1<State>;
    /** The queue of pending props */
    queue: PendingProps$1<State>[];
    /** The current controller-only props (eg: `onFrame` and async state) */
    protected _props: CachedProps<State>;
    /** The spring values that manage their animations */
    protected _springs: Indexable<SpringValue>;
    constructor(props?: ControllerProps<State>);
    /** Equals true when no springs are animating */
    readonly idle: boolean;
    /** Get all existing `SpringValue` objects. This clones the internal store. */
    readonly springs: { [P_1 in keyof (Indexable<SpringValue<unknown> | undefined> & ([State] extends [Any] ? unknown : { [P in keyof State]: SpringValue<Exclude<State[P], void>> | Extract<State[P], void>; }))]: (Indexable<SpringValue<unknown> | undefined> & ([State] extends [Any] ? unknown : { [P in keyof State]: SpringValue<Exclude<State[P], void>> | Extract<State[P], void>; }))[P_1]; };
    /** Get an existing `SpringValue` object by its key. */
    get<P extends keyof State>(key: P): SpringValue<State[P]>;
    get(key: string): SpringValue<unknown> | undefined;
    /** Push an update onto the queue of each value. */
    update(props: ControllerProps<State> | Falsy): this;
    /**
     * Start the queued animations for every spring, and resolve the returned
     * promise once all queued animations have finished or been cancelled.
     *
     * When you pass a queue (instead of nothing), that queue is used instead of
     * the queued animations added with the `update` method, which are left alone.
     */
    start(queue?: OneOrMore<ControllerProps<State>>): Promise<{
        value: any;
        finished: boolean;
    }>;
    /** Stop one animation, some animations, or all animations */
    stop(keys?: OneOrMore<string>): this;
    /** Restart every animation. */
    reset(): this;
    /** Destroy every spring in this controller */
    dispose(): void;
    /** Get the current value of every spring */
    protected _get(): any;
    /** Create a spring for every given key, and ensure they have `Animated` nodes. */
    protected _setSprings(keys: any[], from?: object, to?: object): void;
    /** Prepare an update with the given props. */
    protected _update(propsArg: ControllerProps<State>): PendingProps$1<State>;
    /** @internal Attached as an observer to every spring */
    protected _onChange(value: any, spring: AnimationValue): void;
    /** @internal Called at the end of every animation frame */
    private _onFrame;
}

/**
 * The set of `SpringValue` objects returned by a `useSpring` call (or similar).
 */
declare type SpringValues<T extends object = any> = Remap<Indexable$1<SpringValue<unknown> | undefined> & ([T] extends [Any$1] ? unknown : {
    [P in keyof T]: SpringValue<Exclude<T[P], void>> | Extract<T[P], void>;
})>;
/**
 * The `to` prop in async form.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */
declare type AsyncTo<T, P extends string = string> = ReadonlyArray<{
    [U in P]: SpringUpdate<T, P>;
}[P]> | SpringAsyncFn<T>;
/**
 * A value or set of values that can be animated from/to.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */
declare type GoalValue<T> = T extends Animatable ? T | FluidValue<T> | UnknownProps$1 : T extends object ? UnknownPartial<FluidProps<T>> : never;
/**
 * The `to` prop's possible types.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */
declare type ToProp<T> = GoalValue<T> | AsyncTo<T> | Falsy$1;
/**
 * The `from` prop's possible types.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */
declare type FromProp<T> = GoalValue<T> | Falsy$1;
/**
 * The `from` and `to` props.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */
interface RangeProps<T = any> {
    /**
     * The start values of the first animations.
     *
     * The `reset` prop also uses these values.
     */
    from?: FromProp<T>;
    /**
     * The end values of the next animations.
     *
     *     to: { width: 100, height: 100 }
     *
     * ---
     * To chain animations together, pass an array of updates:
     *
     *     to: [{ width: 100 }, { width: 0, delay: 100 }]
     *
     * ---
     * For scripted animations, pass an async function:
     *
     *     to: async (update) => {
     *       await update({ width: 100 })
     *       await update({ width: 0, delay: 100 })
     *     }
     */
    to?: ToProp<T>;
}
/**
 * The props of a `useSpring` call or its async `update` function.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */
declare type SpringProps<T = any> = AnimationProps & RangeProps<T>;
/**
 * An update to the props of a spring.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */
declare type SpringUpdate<T = any, P extends string = string> = (SpringProps<T> & AnimationEvents & (T extends object ? T extends ReadonlyArray<any> ? unknown : UnknownProps$1 : unknown)) | SpringTo<T, P>;
declare type SpringTo<T = any, P extends string = string> = unknown & ([T] extends [Animatable] ? T | FluidValue<T> | AsyncTo<T, P> : never);
/**
 * Update the props of a spring.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */
declare type SpringUpdateFn<T> = [T] extends [Animatable] ? {
    (to: SpringTo<T>, props?: SpringProps<T>): AsyncResult<T>;
    (props: SpringProps<T>): AsyncResult<T>;
} : [T] extends [object] ? {
    (props: ControllerProps<T>): AsyncResult<T>;
} : {
    (props: SpringProps<T>): AsyncResult<T>;
};
/**
 * Stop every animating `SpringValue` at its current value.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */
declare type SpringStopFn<T> = T extends object ? T extends ReadonlyArray<number | string> ? (() => void) : ((keys?: OneOrMore<string>) => void) : (() => void);
/**
 * Update the props of each spring, individually or all at once.
 *
 * The `T` parameter should only contain animated props.
 */
interface SpringsUpdateFn<State extends Indexable$1> {
    (props: OneOrMore<ControllerProps<State>> | ((index: number, ctrl: Controller<State>) => ControllerProps<State> | null)): SpringHandle<State>;
}
/**
 * An async function that can update or cancel the animations of a spring.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */
interface SpringAsyncFn<T> {
    (next: SpringUpdateFn<T>, stop: SpringStopFn<T>): Promise<void> | undefined;
}
/**
 * The object attached to the `ref` prop by the `useSprings` hook.
 *
 * The `T` parameter should only contain animated props.
 */
interface SpringHandle<T extends Indexable$1 = any> {
    controllers: readonly Controller<T>[];
    update: SpringsUpdateFn<T>;
    start: () => AsyncResult<T[]>;
    stop: SpringStopFn<T>;
}
declare type SpringConfig = Partial<Omit<AnimationConfig, 'w0'>>;

declare function useChain(
  refs: ReadonlyArray<RefObject<SpringHandle>>,
  timeSteps?: number[],
  timeFrame?: number
): void

/**
 * The props that `useSpring` recognizes.
 */
declare type UseSpringProps<Props extends object = any> = unknown & PickAnimated<Props> extends infer State ? ControllerProps<State> & {
    /**
     * Used to access the imperative API.
     *
     * Animations never auto-start when `ref` is defined.
     */
    ref?: RefObject<SpringHandle<State>>;
} : never;
/**
 * Animations are updated on re-render.
 */
declare function useSpring<Props extends UnknownProps$1>(props: (Props & Valid<Props, UseSpringProps<Props>>) | UseSpringProps): SpringValues<PickAnimated<Props>>;
/**
 * When the `deps` argument exists, you get the `update` and `stop` function.
 */
declare function useSpring<Props extends UnknownProps$1>(props: (Props & Valid<Props, UseSpringProps<Props>>) | UseSpringProps, deps: any[] | undefined): [SpringValues<PickAnimated<Props>>, SpringUpdateFn<PickAnimated<Props>>, SpringStopFn<UnknownProps$1>];
/**
 * When the `deps` argument exists, the `props` function is called whenever
 * the `deps` change on re-render.
 *
 * Without the `deps` argument, the `props` function is only called once.
 */
declare function useSpring<Props extends UnknownProps$1>(props: () => (Props & Valid<Props, UseSpringProps<Props>>) | UseSpringProps, deps?: any[]): [SpringValues<PickAnimated<Props>>, SpringUpdateFn<PickAnimated<Props>>, SpringStopFn<UnknownProps$1>];

declare type UseSpringsProps<Props extends object = any> = Merge<UseSpringProps<Props>, {
    ref?: RefObject<SpringHandle<PickAnimated<Props>>>;
}>;
/**
 * Animations are updated on re-render.
 */
declare function useSprings<P extends object[], Props extends object = P[number]>(length: number, props: P & UseSpringsProps<Props>[]): SpringValues<PickAnimated<Props>>[];
/**
 * When the `deps` argument exists, you get the `update` and `stop` function.
 */
declare function useSprings<P extends object[], Props extends object = P[number]>(length: number, props: P & UseSpringsProps<Props>[], deps: any[] | undefined): [SpringValues<PickAnimated<Props>>[], SpringsUpdateFn<PickAnimated<Props>>, SpringStopFn<UnknownProps$1>];
/**
 * When the `deps` argument exists, the `props` function is called whenever
 * the `deps` change on re-render.
 *
 * Without the `deps` argument, the `props` function is only called once.
 */
declare function useSprings<Props extends object>(length: number, props: (i: number, ctrl: Controller) => Props & UseSpringsProps<Props>, deps?: any[]): [SpringValues<PickAnimated<Props>>[], SpringsUpdateFn<PickAnimated<Props>>, SpringStopFn<UnknownProps$1>];

declare function useTrail<Props extends object>(length: number, props: (i: number, ctrl: Controller) => (Props & Valid<Props, UseSpringProps<Props>>) | UseSpringProps, deps?: any[]): [SpringValues<PickAnimated<Props>>[], SpringsUpdateFn<PickAnimated<Props>>, SpringStopFn<UnknownProps$1>];
declare function useTrail<Props extends object>(length: number, props: (Props & Valid<Props, UseSpringProps<Props>>) | UseSpringProps, deps?: any[]): SpringValues<PickAnimated<Props>>[];

declare type Phase$1 = number & {
    __type: 'TransitionPhase';
};
declare type UnknownProps = Indexable$1<any>;
declare type PhaseProp<Item> = Falsy$1 | OneOrMore<UseSpringProps> | ((item: Item, index: number) => UseSpringProps | AsyncTo<UnknownProps> | Falsy$1);
declare type PhaseProps<Item = any, From = {}> = {
    from?: From & (FromProp<UnknownProps> | ((item: Item, index: number) => FromProp<UnknownProps>));
    initial?: From & (FromProp<UnknownProps> | ((item: Item, index: number) => FromProp<UnknownProps>));
    enter?: PhaseProp<Item>;
    update?: PhaseProp<Item>;
    leave?: PhaseProp<Item>;
};
declare type Key = string | number;
declare type ItemKeys<T = any> = OneOrMore<Key> | ((item: T) => Key) | null;
declare type UseTransitionProps<Item = any> = Merge<AnimationProps & AnimationEvents, {
    /**
     * Used to access the imperative API.
     *
     * Animations never auto-start when `ref` is defined.
     */
    ref?: RefObject<TransitionHandle>;
    key?: ItemKeys<Item>;
    sort?: (a: Item, b: Item) => number;
    trail?: number;
    expires?: number;
}>;
/** The imperative `ref` API */
declare type TransitionHandle = Merge<SpringHandle, {
    update(props: ControllerProps): TransitionHandle;
}>;
/** The function returned by `useTransition` */
interface TransitionFn<Item = any, State extends object = any> {
    (render: (values: SpringValues<State>, item: Item, transition: TransitionState<Item>) => ReactNode): ReactNode[];
}
declare function useTransition<Item, From, Props extends object>(data: OneOrMore<Item>, props: Props & PhaseProps<Item, From> & UseTransitionProps<Item>, deps?: any[]): TransitionFn<Item, PickAnimated<Props>>;
interface TransitionState<Item = any> {
    key: any;
    item: Item;
    ctrl: Controller;
    phase: Phase$1;
    /** Destroy no later than this date */
    expiresBy?: number;
    expirationId?: number;
}

//
// <Spring/>
//

type SpringComponentProps<Props extends object = any> = unknown &
  UseSpringProps<Props> & {
    children: (values: SpringValues<PickAnimated<Props>>) => ReactNode
  }

/**
 * The `Spring` component passes `SpringValue` objects to your render prop.
 */
declare const Spring: <Props extends object>(
  props:
    | (Props & Valid<Props, SpringComponentProps<Props>>)
    | SpringComponentProps
) => JSX.Element

//
// <Trail/>
//

type TrailComponentProps<Item, Props extends object = any> = unknown &
  UseSpringProps<Props> & {
    items: readonly Item[]
    children: (
      item: NoInfer<Item>,
      index: number
    ) => ((values: SpringValues<PickAnimated<Props>>) => ReactNode) | Falsy
  }

declare const Trail: <Item, Props extends object>(
  props:
    | (Props & Valid<Props, TrailComponentProps<Item, Props>>)
    | TrailComponentProps<NoInfer<Item>>
) => JSX.Element

//
// <Transition/>
//

type TransitionComponentProps<Item, Props extends object = any> = unknown &
  UseTransitionProps<Item> & {
    keys?: ItemKeys<NoInfer<Item>>
    items: OneOrMore$1<Item>
    children: (
      item: NoInfer<Item>,
      phase: TransitionPhase,
      index: number
    ) => ((values: SpringValues<PickAnimated<Props>>) => ReactNode) | Falsy
  }

declare const Transition: <Item, Props extends object>(
  props:
    | (Props & Valid<Props, TransitionComponentProps<Item, Props>>)
    | TransitionComponentProps<Item>
) => JSX.Element

/** Map the value of one or more dependencies */
declare const to: Interpolator;
/** @deprecated Use the `to` export instead */
declare const interpolate: Interpolator;
/** Extract the raw value types that are being interpolated */
declare type Interpolated<T extends ReadonlyArray<any>> = {
    [P in keyof T]: T[P] extends {
        get(): infer U;
    } ? U : never;
};
/**
 * This interpolates one or more `FluidValue` objects.
 * The exported `interpolate` function uses this type.
 */
interface Interpolator {
    <In, Out>(parent: FluidValue$1<In>, interpolator: InterpolatorFn<In, Out>): Into<Out>;
    <In extends ReadonlyArray<FluidValue$1>, Out>(parents: In, interpolator: (...args: Interpolated<In>) => Out): Into<Out>;
    <Out>(parents: OneOrMore$2<FluidValue$1>, config: InterpolatorConfig<Out>): Into<Animatable$1<Out>>;
    <Out>(parents: OneOrMore$2<FluidValue$1<number>> | FluidValue$1<number[]>, range: readonly number[], output: readonly Constrain$1<Out, Animatable$1>[], extrapolate?: ExtrapolateType): Into<Animatable$1<Out>>;
}

declare const config: {
    readonly default: {
        readonly tension: 170;
        readonly friction: 26;
    };
    readonly gentle: {
        readonly tension: 120;
        readonly friction: 14;
    };
    readonly wobbly: {
        readonly tension: 180;
        readonly friction: 12;
    };
    readonly stiff: {
        readonly tension: 210;
        readonly friction: 20;
    };
    readonly slow: {
        readonly tension: 280;
        readonly friction: 60;
    };
    readonly molasses: {
        readonly tension: 280;
        readonly friction: 120;
    };
};

/** Advance all animations forward one frame */
declare const update: () => boolean;

declare type FrameUpdater = (this: FrameLoop, time?: number) => boolean;
declare type RequestFrameFn = (cb: FrameRequestCallback) => number | void;
declare class FrameLoop {
    /**
     * The animated springs
     */
    springs: SpringValue[];
    /**
     * True when at least one spring is animating.
     */
    active: boolean;
    /**
     * The timestamp of the most recent frame.
     *
     * Equals `undefined` if nothing is animating.
     */
    lastTime: number;
    /**
     * Process the next animation frame.
     *
     * Can be passed to `requestAnimationFrame` quite nicely.
     *
     * This advances any `Controller` instances added to it with the `start` function.
     */
    update: FrameUpdater;
    /** Equals true when a frame is being processed. */
    updating: boolean;
    /** Equals true when writing to native attributes. */
    writing: boolean;
    protected _queues: Set<FrameRequestCallback>[];
    /** `onWrite` callbacks are flushed on every frame, after `onFrame` callbacks are flushed. */
    protected _writes: Set<FrameRequestCallback>;
    protected _requestFrame: RequestFrameFn;
    constructor({ update, requestFrame, }?: {
        update?: FrameUpdater;
        requestFrame?: RequestFrameFn;
    });
    /**
     * Schedule a function to run at the end of the current frame,
     * after all springs have been updated.
     *
     * Pass `true` as the 2nd argument to run at the end of the **next** frame.
     */
    onFrame(cb: FrameRequestCallback, next?: boolean): void;
    /**
     * Schedule a function run at the end of the current frame,
     * after all `onFrame` callbacks have been called.
     *
     * Calling `onWrite` from inside an `onWrite` callback simply
     * calls the nested write immediately.
     */
    onWrite(cb: FrameRequestCallback): void;
    /**
     * Start animating the given spring.
     *
     * Beware: Never `start` the same spring twice (without `stop` between).
     */
    start(spring: SpringValue): void;
    protected _start(): void;
    /**
     * Stop animating the given spring
     */
    stop(spring: SpringValue): this;
    /**
     * Advance an animation forward one frame.
     */
    advance(dt: number, spring: SpringValue): void;
}

export { AnimationResult, Controller, ControllerProps, DefaultProps, ForwardProps, FrameLoop, Interpolated, Interpolator, ItemKeys, OnFrame, PendingProps, Phase$1 as Phase, ReservedProps, Spring, SpringAsyncFn, SpringConfig, SpringHandle, SpringProps, SpringStopFn, SpringUpdate, SpringUpdateFn, SpringValue, SpringValues, SpringsUpdateFn, Trail, Transition, TransitionFn, TransitionHandle, TransitionPhase, TransitionState, UseSpringProps, UseSpringsProps, UseTransitionProps, config, interpolate, to, update, useChain, useSpring, useSprings, useTrail, useTransition };
