import { useEffect } from 'react';
import { Indexable, FluidValue } from './types';
export declare const FluidType = "__$FluidType";
/** Let the given object be observed by any `FluidObserver` */
export declare const makeFluidValue: <T extends Indexable<any>>(value: T) => T;
export declare const isFluidValue: (value: any) => value is FluidValue<any>;
export declare const defineHidden: (obj: any, key: any, value: any) => any;
interface IsArray {
    <T>(a: T): a is T & readonly any[];
}
export declare const is: {
    arr: IsArray;
    obj: <T extends any>(a: T) => a is Exclude<T & Indexable<any>, Function | readonly any[]>;
    fun: (a: unknown) => a is Function;
    str: (a: unknown) => a is string;
    num: (a: unknown) => a is number;
    und: (a: unknown) => a is undefined;
};
/** Compare animatable values */
export declare function isEqual(a: any, b: any): boolean;
export declare const needsInterpolation: (value: unknown) => value is string;
interface EachFn {
    <T = any, This = any>(obj: ReadonlySet<T>, cb: (this: This, value: T) => void, ctx?: This): void;
    <P = any, T = any, This = any>(obj: ReadonlyMap<P, T>, cb: (this: This, value: T, key: P) => void, ctx?: This): void;
    <T = any, This = any>(arr: readonly T[], cb: (this: This, value: T, index: number) => void, ctx?: This): void;
    <T extends Indexable = any, This = any>(obj: T, cb: (this: This, value: T[keyof T], key: keyof T) => void, ctx?: This): void;
}
/** An unsafe object/array/set iterator that allows for better minification */
export declare const each: EachFn;
export declare const toArray: <T>(a: T) => Exclude<T, void> extends readonly any[] ? (readonly any[] & Exclude<T, void>)[number][] extends readonly any[] & Exclude<T, void> ? readonly (Exclude<T, void> extends readonly (infer U)[] ? U : Exclude<T, void>)[] : readonly any[] & Exclude<T, void> : readonly (Exclude<T, void> extends readonly (infer U_1)[] ? U_1 : Exclude<T, void>)[];
export declare const useOnce: (effect: import("react").EffectCallback) => void;
export declare const useForceUpdate: () => () => void;
/** Use a value from the previous render */
export declare function usePrev<T>(value: T): T | undefined;
/**
 * React calls `console.warn` when using `useLayoutEffect` on the server.
 * To get around it, we can conditionally `useEffect` on the server (no-op) and
 * `useLayoutEffect` on the client.
 */
export declare const useIsomorphicLayoutEffect: typeof useEffect;
export {};
