{"ast":null,"code":"import { useIsomorphicLayoutEffect, each, is, toArray, isFluidValue, needsInterpolation, isEqual, usePrev, useOnce, useForceUpdate, Globals } from '@react-spring/shared';\nexport { Globals, createInterpolator, isFluidValue, makeFluidValue } from '@react-spring/shared';\nimport React, { useMemo as useMemo$1, useImperativeHandle, useRef } from 'react';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { frameLoop, createStringInterpolator, now, skipAnimation, requestAnimationFrame, performanceNow } from '@react-spring/shared/globals';\nimport { useMemoOne } from 'use-memo-one';\nimport { AnimationValue, isAnimationValue, AnimatedString, AnimatedValue, AnimatedArray, Into } from '@react-spring/animated';\nexport { AnimationValue, Into, isAnimationValue } from '@react-spring/animated';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps, timeFrame) {\n  if (timeFrame === void 0) {\n    timeFrame = 1000;\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        if (!ref.current) return;\n        const controllers = ref.current.controllers;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              props.delay = delay + (props.delay || 0);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, ref => {\n        const _ref = ref.current || {},\n              controllers = _ref.controllers,\n              start = _ref.start;\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => ctrl.queue.push(...updates[i]));\n            return start();\n          });\n        }\n      });\n    }\n  });\n}\n\nconst useMemo = (create, deps) => useMemoOne(create, deps || [{}]);\n\nfunction callProp(value) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return is.fun(value) ? value(...args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\n\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\n\nconst getProps = (props, i, arg) => is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : _extends({}, props);\n/** These props can have default values */\n\n\nconst DEFAULT_PROPS = ['config', 'immediate', 'onAnimate', 'onStart', 'onChange', 'onRest'];\nconst RESERVED_PROPS = {\n  children: 1,\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  reset: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  lazy: 1,\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  leave: 1,\n  update: 1,\n  onAnimate: 1,\n  onStart: 1,\n  onRest: 1,\n  onChange: 1,\n  onFrame: 1\n};\n/**\r\n * Extract any properties whose keys are *not* reserved for customizing your\r\n * animations. All hooks use this function, which means `useTransition` props\r\n * are reserved for `useSpring` calls, etc.\r\n */\n\nfunction getForwardProps(props) {\n  const forward = {};\n  each(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n    }\n  });\n  return forward;\n}\n\nfunction interpolateTo(props) {\n  const to = getForwardProps(props);\n  const out = {\n    to\n  };\n  each(props, (val, key) => key in to || (out[key] = val));\n  return out;\n}\n/**\r\n * Start an async chain or an async script.\r\n *\r\n * You should always wrap `runAsync` calls with `scheduleProps` so that\r\n * you have access to `RunAsyncProps` instead of the usual `SpringProps`.\r\n *\r\n * The `T` parameter can be a set of animated values (as an object type)\r\n * or a primitive type for a single animated value.\r\n */\n\n\nasync function runAsync(to, props, state, getValue, getPaused, update, stop) {\n  if (props.cancel) {\n    state.asyncTo = undefined;\n    return {\n      value: getValue(),\n      cancelled: true\n    };\n  } // Wait for the previous async animation to be cancelled.\n  else if (props.reset) {\n      await state.promise;\n    } // Async animations are only replaced when \"props.to\" changes\n    // or when \"props.reset\" equals true.\n    else if (to === state.asyncTo) {\n        return state.promise;\n      }\n\n  state.asyncTo = to;\n  return state.promise = (async () => {\n    const asyncId = props.asyncId;\n    const cancelToken = Symbol.for('cancel');\n\n    const isCancelled = () => to !== state.asyncTo || asyncId <= (state.cancelId || 0);\n\n    const defaultProps = {};\n    each(DEFAULT_PROPS, prop => {\n      if (prop == 'onRest') return;\n\n      if (/function|object/.test(typeof props[prop])) {\n        defaultProps[prop] = props[prop];\n      }\n    });\n\n    const animate = (arg1, arg2) => {\n      if (isCancelled()) {\n        throw cancelToken;\n      }\n\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {\n        to: arg1\n      });\n      each(defaultProps, (value, prop) => {\n        if (is.und(props[prop])) {\n          props[prop] = value;\n        }\n      });\n      const parentTo = state.asyncTo;\n      return update(props).then(async result => {\n        if (state.asyncTo == null) {\n          state.asyncTo = parentTo;\n        }\n\n        if (isCancelled()) {\n          throw cancelToken;\n        }\n\n        if (getPaused()) {\n          await new Promise(resolve => {\n            state.unpause = resolve;\n          });\n          state.unpause = undefined;\n        }\n\n        return result;\n      });\n    };\n\n    let result;\n\n    try {\n      // Async sequence\n      if (is.arr(to)) {\n        for (const props of to) {\n          await animate(props);\n        }\n      } // Async script\n      else if (is.fun(to)) {\n          await to(animate, stop);\n        }\n\n      result = {\n        value: getValue(),\n        finished: true\n      };\n    } catch (err) {\n      if (err !== cancelToken) {\n        throw err;\n      }\n\n      result = {\n        value: getValue(),\n        cancelled: true\n      };\n    } finally {\n      state.promise = undefined;\n\n      if (to == state.asyncTo) {\n        state.asyncTo = undefined;\n      }\n    }\n\n    if (props.onRest) {\n      props.onRest(result);\n    }\n\n    return result;\n  })();\n} //\n// scheduleProps(props, state, action)\n//\n\n/**\r\n * Pass props to your action when any delay is finished and the\r\n * props weren't cancelled before then.\r\n */\n\n\nfunction scheduleProps(asyncId, props, state, action) {\n  return new Promise((resolve, reject) => {\n    let delay = props.delay,\n        cancel = props.cancel,\n        reset = props.reset;\n\n    if (is.num(delay) && delay > 0) {\n      setTimeout(run, delay);\n    } else run();\n\n    function run() {\n      // Might be cancelled during delay.\n      if (asyncId <= (state.cancelId || 0)) {\n        cancel = true;\n      } else {\n        cancel = matchProp(cancel, state.key);\n\n        if (cancel) {\n          state.cancelId = asyncId;\n        }\n      }\n\n      reset = !cancel && matchProp(reset, state.key);\n\n      try {\n        action(_extends({}, props, {\n          asyncId,\n          cancel,\n          reset\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n} // The `mass` prop defaults to 1\n\n\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n/** The spring cannot be animated */\n\nconst DISPOSED = 'DISPOSED';\n/** The spring has not animated yet */\n\nconst CREATED = 'CREATED';\n/** The spring has animated before */\n\nconst IDLE = 'IDLE';\n/** The spring is frozen in time */\n\nconst PAUSED = 'PAUSED';\n/** The spring is animating */\n\nconst ACTIVE = 'ACTIVE';\n\nconst noop = () => {};\n\nconst BASE_CONFIG = _extends({}, config.default, {\n  mass: 1,\n  velocity: 0,\n  progress: 0,\n  easing: t => t,\n  clamp: false\n});\n/** An opaque animatable value */\n\n\nclass SpringValue extends AnimationValue {\n  constructor(key) {\n    super(key);\n    /** The animation state */\n\n    this.animation = {\n      value: this\n    };\n    /** The lifecycle phase of this spring */\n\n    this._phase = CREATED;\n    /** The last time each prop changed */\n\n    this._timestamps = {};\n    /** Some props have customizable default values */\n\n    this._defaultProps = {};\n    /** Cancel any update from before this timestamp */\n\n    this._lastAsyncId = 0;\n    this._state = {\n      key\n    };\n  }\n\n  get idle() {\n    return !this.is(ACTIVE);\n  }\n  /** Check the current phase */\n\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Set the current value, while stopping the current animation */\n\n\n  set(value) {\n    if (this._set(value) && this.idle) {\n      // Since \"_stop\" calls \"_onChange\" only when not idle, we need this.\n      this._onChange(this.get(), true);\n    }\n\n    this._stop();\n\n    return this;\n  }\n  /**\r\n   * Freeze the active animation in time.\r\n   * This does nothing when not animating.\r\n   *\r\n   * Call `start` to unpause.\r\n   */\n\n\n  pause() {\n    checkDisposed(this, 'pause');\n\n    if (!this.idle) {\n      this._phase = PAUSED;\n      frameLoop.stop(this);\n    }\n  }\n  /**\r\n   * Skip to the end of the current animation.\r\n   *\r\n   * All `onRest` callbacks are passed `{finished: true}`\r\n   */\n\n\n  finish(to) {\n    if (!this.idle) {\n      const anim = this.animation; // Decay animations have an implicit goal.\n\n      if (!anim.config.decay && is.und(to)) {\n        to = anim.to;\n      } // Set the value if we can.\n\n\n      if (!is.und(to)) {\n        this._set(to);\n      } // Exit the frameloop.\n\n\n      this._stop(true);\n    }\n\n    return this;\n  }\n  /** Push props into the pending queue. */\n\n\n  update(props) {\n    checkDisposed(this, 'update'); // Ensure the initial value can be accessed by animated components.\n\n    this.setNodeWithProps(props);\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n\n  async start(to, arg2) {\n    checkDisposed(this, 'start'); // Unpause if possible.\n\n    if (this.is(PAUSED)) {\n      this._start();\n\n      if (this._state.asyncTo) {\n        this._state.unpause();\n      }\n    }\n\n    let queue;\n\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : _extends({}, arg2, {\n        to\n      })];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    await Promise.all(queue.map(props => this._animate(props)));\n    return {\n      finished: true,\n      value: this.get(),\n      spring: this\n    };\n  }\n  /**\r\n   * Stop the current animation, and cancel any delayed updates.\r\n   */\n\n\n  stop() {\n    if (!this.is(DISPOSED)) {\n      this._state.cancelId = this._lastAsyncId;\n\n      this._to(this.get());\n\n      this._stop();\n    }\n\n    return this;\n  }\n  /** Restart the animation. */\n\n\n  reset() {\n    this._animate({\n      reset: true\n    });\n  }\n  /** Prevent future animations, and stop the current animation */\n\n\n  dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = undefined;\n      }\n\n      this.stop();\n      this._phase = DISPOSED;\n    }\n  }\n  /** Observe value changes. To stop observing, call the returned function. */\n\n\n  onChange(fn) {\n    this._children.add(fn);\n\n    return () => this._children.delete(fn);\n  }\n  /** @internal */\n\n\n  onParentChange(value, idle) {\n    const anim = this.animation; // The \"FrameLoop\" handles everything other than immediate animation.\n\n    if (anim.immediate) {\n      if (idle) {\n        this.finish(value);\n      } else {\n        this._set(value);\n      }\n    } // When our parent is not a spring, it won't tell us to enter the frameloop\n    // because it never does so itself. Instead, we must react to value changes.\n    else if (this.idle) {\n        anim.fromValues = anim.values.map(node => node.lastPosition);\n\n        this._start();\n      }\n  }\n  /** @internal Called by the frameloop */\n\n\n  onFrame(idle, changed) {\n    if (idle) {\n      this.finish();\n    } else if (changed) {\n      this._onChange(this.get());\n    }\n  }\n  /**\r\n   * @internal\r\n   * Analyze the given `value` to determine which data type is being animated.\r\n   * Then, create an `Animated` node for that data type and make it our `node`.\r\n   */\n\n\n  setNodeWithValue(value) {\n    if (value != null) {\n      this.node = this._getNodeType(value).create(computeGoal(value));\n    }\n  }\n  /**\r\n   * @internal\r\n   * Analyze the given `props` to determine which data type is being animated.\r\n   * Then, create an `Animated` node for that data type and make it our `node`.\r\n   * If we already have a `node`, do nothing but return the `{from, to}` range.\r\n   */\n\n\n  setNodeWithProps(props) {\n    const range = this._getRange(props);\n\n    if (!this.node) {\n      this.setNodeWithValue(range.from != null ? range.from : range.to);\n    }\n\n    return range;\n  }\n  /** Return the `Animated` node constructor for a given value */\n\n\n  _getNodeType(value) {\n    const parent = isAnimationValue(value) ? value : null;\n    const parentType = parent && parent.node && parent.node.constructor;\n\n    if (!parent && isFluidValue(value)) {\n      value = value.get();\n    }\n\n    return parentType == AnimatedString ? AnimatedValue : parentType || (is.arr(value) ? AnimatedArray : needsInterpolation(value) ? AnimatedString : AnimatedValue);\n  }\n  /** Pluck the `to` and `from` props */\n\n\n  _getRange(props) {\n    const to = props.to,\n          from = props.from;\n    const key = this.key || '';\n    return {\n      to: !is.obj(to) || isFluidValue(to) ? to : to[key],\n      from: !is.obj(from) || isFluidValue(from) ? from : from[key]\n    };\n  }\n  /** Update this value's animation using the given props. */\n\n\n  _animate(props) {\n    // Ensure the initial value can be accessed by animated components.\n    const range = this.setNodeWithProps(props);\n    const timestamp = now();\n    return scheduleProps(++this._lastAsyncId, props, this._state, (props, resolve) => {\n      const to = props.to;\n\n      if (is.arr(to) || is.fun(to)) {\n        resolve(runAsync(to, props, this._state, () => this.get(), () => this.is(PAUSED), this.start.bind(this), this.stop.bind(this)));\n      } else if (props.cancel) {\n        this.stop();\n        resolve({\n          value: this.get(),\n          cancelled: true\n        });\n      } else {\n        this._update(range, props, timestamp, resolve);\n      }\n    });\n  }\n  /** Update the internal `animation` object */\n\n\n  _update(_ref, props, timestamp, resolve) {\n    let to = _ref.to,\n        from = _ref.from;\n    const defaultProps = this._defaultProps;\n    /** Get the value of a prop, or its default value */\n\n    const get = prop => !is.und(props[prop]) ? props[prop] : defaultProps[prop];\n\n    const onAnimate = get('onAnimate');\n\n    if (onAnimate) {\n      onAnimate(props, this);\n    } // Cast from a partial type.\n\n\n    const anim = this.animation;\n    const timestamps = this._timestamps;\n    /** Return true if our prop can be used. This only affects delayed props. */\n\n    const diff = prop => {\n      if (timestamp >= (timestamps[prop] || 0)) {\n        timestamps[prop] = timestamp;\n        return true;\n      }\n\n      return false;\n    };\n\n    const prevTo = anim.to,\n          prevFrom = anim.from; // The \"reverse\" prop only affects one update.\n\n    if (props.reverse) {\n      var _ref2 = [from, to];\n      to = _ref2[0];\n      from = _ref2[1];\n    }\n\n    if (!is.und(to) && diff('to')) {\n      this._to(to);\n    } else {\n      to = prevTo;\n    }\n\n    if (!is.und(from) && diff('from')) {\n      anim.from = from;\n    } else {\n      from = anim.from;\n    }\n\n    if (isFluidValue(from)) {\n      from = from.get();\n    }\n\n    const reset = props.reset && !is.und(from);\n    const changed = !is.und(to) && !isEqual(to, prevTo);\n    const parent = isFluidValue(to) && to;\n    /** The current value */\n\n    let value = reset ? from : this.get();\n\n    if (is.und(from)) {\n      from = value;\n    }\n    /** When true, this spring must be in the frameloop. */\n\n\n    let started = !!parent || (changed || reset) && !isEqual(value, to);\n    /** The initial velocity before this `animate` call. */\n\n    const lastVelocity = anim.config ? anim.config.velocity : 0; // The \"config\" prop either overwrites or merges into the existing config.\n\n    let config = props.config;\n\n    if (config || started || !anim.config) {\n      const key = this.key || '';\n      config = _extends({}, callProp(defaultProps.config, key), callProp(config, key));\n\n      if (!started && canMergeConfigs(config, anim.config)) {\n        Object.assign(anim.config, config);\n      } else {\n        anim.config = config = _extends({}, BASE_CONFIG, config);\n      } // Derive \"tension\" and \"friction\" from \"frequency\" and \"damping\".\n\n\n      if (!is.und(config.frequency)) {\n        const damping = is.und(config.damping) ? 1 : config.damping;\n        config.tension = Math.pow(config.frequency, 2) * config.mass;\n        config.friction = damping * Math.sqrt(config.tension * config.mass) / 0.5;\n      } // Cache the angular frequency in rad/ms\n\n\n      config.w0 = Math.sqrt(config.tension / config.mass) / 1000;\n    } else {\n      config = anim.config;\n    } // Always start animations with velocity.\n\n\n    if (!started && (config.decay || !is.und(to))) {\n      started = !isEqual(config.velocity, lastVelocity);\n    } // Reset our internal `Animated` node if starting.\n\n\n    let node = this.node;\n    let nodeType;\n\n    if (changed) {\n      nodeType = this._getNodeType(to);\n\n      if (nodeType !== node.constructor) {\n        throw Error(`Cannot animate to the given \"to\" prop, because the current value has a different type`);\n      }\n    } else {\n      nodeType = node.constructor;\n    } // The final value of our animation, excluding the \"to\" value.\n    // The \"FrameLoop\" decides our goal value when \"parent\" exists.\n\n\n    let goal = parent ? null : computeGoal(to);\n\n    if (nodeType == AnimatedString) {\n      from = 0;\n      goal = 1;\n    } // Ensure the current value equals the \"from\" value when reset\n    // and when the \"from\" value is updated before the first animation.\n\n\n    if (reset || this.is(CREATED) && !is.und(anim.from) && !isEqual(anim.from, prevFrom)) {\n      node.setValue(value = from);\n    } // Event props are replaced on every update.\n\n\n    anim.onStart = get('onStart');\n    anim.onChange = get('onChange'); // Update the default props.\n\n    if (props.default) {\n      each(DEFAULT_PROPS, prop => {\n        // Default props can only be null, an object, or a function.\n        if (/function|object/.test(typeof props[prop])) {\n          defaultProps[prop] = props[prop];\n        }\n      });\n    }\n\n    if (!started) {\n      // Resolve the \"animate\" promise.\n      return resolve({\n        value,\n        spring: this,\n        finished: true\n      });\n    } // This must come *before* \"fromValues\" is set,\n    // because it updates \"node.lastPosition\"\n\n\n    this._reset();\n\n    anim.values = node.getPayload();\n    anim.toValues = parent ? null : toArray(goal);\n    anim.fromValues = anim.values.map(node => node.lastPosition);\n    anim.immediate = !(parent || is.num(goal) || is.arr(goal)) || !!matchProp(get('immediate'), this.key);\n    const onRestQueue = anim.onRest; // The \"onRest\" prop is always first in the queue.\n\n    anim.onRest = [get('onRest') || noop, resolve]; // Resolve the promise for unfinished animations.\n\n    if (onRestQueue && onRestQueue.length > 1) {\n      const result = {\n        value,\n        spring: this,\n        cancelled: true\n      }; // Skip the \"onRest\" prop, as the animation is still active.\n\n      for (let i = 1; i < onRestQueue.length; i++) {\n        onRestQueue[i](result);\n      }\n    }\n\n    this._start();\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n\n\n  _to(value) {\n    const anim = this.animation;\n\n    if (isFluidValue(anim.to)) {\n      if (value == anim.to) return;\n      anim.to.removeChild(this);\n    }\n\n    anim.to = value;\n\n    if (isFluidValue(value)) {\n      value.addChild(this);\n      this.priority = (value.priority || 0) + 1;\n    } else {\n      this.priority = 0;\n    }\n  }\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n\n\n  _set(value) {\n    if (isFluidValue(value)) {\n      value = value.get();\n    }\n\n    const node = this.node;\n\n    if (node) {\n      if (isEqual(value, node.getValue())) {\n        return false;\n      }\n\n      node.setValue(value);\n    } else {\n      this.setNodeWithValue(value);\n    }\n\n    return true;\n  }\n  /** Notify change observers */\n\n\n  _onChange(value, idle) {\n    if (idle === void 0) {\n      idle = false;\n    }\n\n    const anim = this.animation;\n\n    if (!anim.changed && !idle) {\n      anim.changed = true; // The \"onStart\" prop is called on the first change after entering the\n      // frameloop, but never for immediate animations.\n\n      if (anim.onStart) {\n        anim.onStart(this);\n      }\n    }\n\n    if (anim.onChange) {\n      anim.onChange(value, this);\n    }\n\n    super._onChange(value, idle);\n  }\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      // Re-enter the frameloop so our new priority is used.\n      frameLoop.stop(this).start(this);\n    }\n\n    super._onPriorityChange(priority);\n  }\n  /** Reset our node, and the nodes of every descendant spring */\n\n\n  _reset(goal) {\n    if (goal === void 0) {\n      goal = computeGoal(this.animation.to);\n    }\n\n    super._reset(goal);\n  }\n  /** Enter the frameloop */\n\n\n  _start() {\n    if (this.idle) {\n      this._phase = ACTIVE; // Animations without \"onRest\" cannot enter the frameloop.\n\n      const anim = this.animation;\n\n      if (anim.onRest) {\n        anim.changed = false; // The \"skipAnimation\" global avoids the frameloop.\n\n        if (skipAnimation) {\n          this.finish(anim.to);\n        } else {\n          frameLoop.start(this);\n        }\n      } // Tell animatable children to enter the frameloop.\n\n\n      each(this._children, child => {\n        if (child instanceof SpringValue) {\n          child._start();\n        }\n      });\n    }\n  }\n  /** Exit the frameloop and notify `onRest` listeners */\n\n\n  _stop(finished) {\n    if (finished === void 0) {\n      finished = false;\n    }\n\n    if (!this.idle) {\n      this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n      this._onChange(this.get(), true);\n\n      const anim = this.animation;\n      const onRestQueue = anim.onRest; // Animations without \"onRest\" never enter the frameloop.\n\n      if (onRestQueue) {\n        frameLoop.stop(this);\n        each(anim.values, node => {\n          node.done = true;\n        }); // Preserve the \"onRest\" prop between animations.\n\n        anim.onRest = [onRestQueue[0]]; // Never call the \"onRest\" prop for immediate or no-op animations.\n\n        if (anim.immediate || !anim.changed) {\n          onRestQueue[0] = noop;\n        }\n\n        const result = {\n          value: this.get(),\n          spring: this,\n          finished\n        };\n        each(onRestQueue, onRest => onRest(result));\n      }\n    }\n  }\n\n} // TODO: makes this tree-shakeable\n\n\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(`Cannot call \"${name}\" of disposed \"${spring.constructor.name}\" object`);\n  }\n} // Merge configs when the existence of \"decay\" or \"duration\" has not changed.\n\n\nfunction canMergeConfigs(src, dest) {\n  return !!dest && is.und(src.decay) == is.und(dest.decay) && is.und(src.duration) == is.und(dest.duration);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\n\nfunction computeGoal(value) {\n  return is.arr(value) ? value.map(computeGoal) : isFluidValue(value) ? computeGoal(value.get()) : needsInterpolation(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\nlet nextId = 1;\nlet lastAsyncId = 0;\n\nclass Controller {\n  constructor(props) {\n    this.id = nextId++;\n    /** The values that changed in the last animation frame */\n\n    this.frame = {};\n    /** Fallback values for undefined props */\n\n    this.defaultProps = {};\n    /** The queue of pending props */\n\n    this.queue = [];\n    /** The current controller-only props (eg: `onFrame` and async state) */\n\n    this._props = {};\n    /** The spring values that manage their animations */\n\n    this._springs = {};\n    this._onChange = this._onChange.bind(this);\n    this._onFrame = this._onFrame.bind(this);\n\n    if (props) {\n      props.default = true;\n      this.start(props);\n    }\n  }\n  /** Equals true when no springs are animating */\n\n\n  get idle() {\n    return !this._props.promise && Object.values(this._springs).every(s => s.idle);\n  }\n  /** Get all existing `SpringValue` objects. This clones the internal store. */\n\n\n  get springs() {\n    return _extends({}, this._springs);\n  }\n\n  get(key) {\n    return this._springs[key];\n  }\n  /** Push an update onto the queue of each value. */\n\n\n  update(props) {\n    if (props) this.queue.push(this._update(props));\n    return this;\n  }\n  /**\r\n   * Start the queued animations for every spring, and resolve the returned\r\n   * promise once all queued animations have finished or been cancelled.\r\n   *\r\n   * When you pass a queue (instead of nothing), that queue is used instead of\r\n   * the queued animations added with the `update` method, which are left alone.\r\n   */\n\n\n  async start(queue) {\n    if (queue) {\n      queue = toArray(queue).map(props => this._update(props));\n    } else {\n      queue = this.queue;\n      this.queue = [];\n    }\n\n    const promises = [];\n    each(queue, props => {\n      const to = props.to,\n            onFrame = props.onFrame,\n            keys = props.keys;\n      const asyncTo = (is.arr(to) || is.fun(to)) && to;\n\n      if (asyncTo) {\n        props.to = undefined;\n      }\n\n      promises.push( // Send updates to every affected key.\n      ...keys.map(key => this._springs[key].start(props)), // Schedule controller-only props.\n      scheduleProps(++lastAsyncId, props, this._props, (props, resolve) => {\n        if (!props.cancel) {\n          // Never reuse \"onFrame\" from a previous update.\n          this._props.onFrame = onFrame || this.defaultProps.onFrame;\n\n          if (onFrame && props.default) {\n            this.defaultProps.onFrame = onFrame;\n          }\n        } // Start, replace, or cancel the async animation.\n\n\n        if (asyncTo) {\n          resolve(runAsync(asyncTo, props, this._props, this._get.bind(this), () => false, // TODO: add pausing to Controller\n          this.start.bind(this), this.stop.bind(this)));\n        } else {\n          resolve({\n            value: 0,\n            finished: !props.cancel\n          });\n        }\n      }));\n    });\n    const results = await Promise.all(promises);\n    return {\n      value: this._get(),\n      finished: results.every(result => result.finished)\n    };\n  }\n  /** Stop one animation, some animations, or all animations */\n\n\n  stop(keys) {\n    if (is.und(keys)) {\n      each(this._springs, spring => spring.stop());\n    } else {\n      each(toArray(keys), key => this._springs[key].stop());\n    }\n\n    return this;\n  }\n  /** Restart every animation. */\n\n\n  reset() {\n    each(this._springs, spring => spring.reset()); // TODO: restart async \"to\" prop\n\n    return this;\n  }\n  /** Destroy every spring in this controller */\n\n\n  dispose() {\n    this._props.asyncTo = undefined;\n    each(this._springs, spring => spring.dispose());\n    this._springs = {};\n  }\n  /** Get the current value of every spring */\n\n\n  _get() {\n    const values = {};\n    each(this._springs, (spring, key) => {\n      values[key] = spring.get();\n    });\n    return values;\n  }\n  /** Create a spring for every given key, and ensure they have `Animated` nodes. */\n\n\n  _setSprings(keys, from, to) {\n    each(keys, key => {\n      if (!this._springs[key]) {\n        const spring = this._springs[key] = new SpringValue(key);\n        spring.addChild(this._onChange);\n        spring.setNodeWithProps({\n          from,\n          to\n        });\n      }\n    });\n  }\n  /** Prepare an update with the given props. */\n\n\n  _update(propsArg) {\n    const props = interpolateTo(propsArg);\n    const keys = props.keys = extractKeys(props, this._springs);\n    let from = props.from,\n        to = props.to; // Avoid sending async \"to\" prop to springs.\n\n    if (is.arr(to) || is.fun(to)) {\n      to = undefined;\n    } // Create our springs and give them values.\n\n\n    if (from || to) {\n      this._setSprings(keys, from, to);\n    }\n\n    return props;\n  }\n  /** @internal Attached as an observer to every spring */\n\n\n  _onChange(value, spring) {\n    if (this._props.onFrame) {\n      this.frame[spring.key] = value;\n      frameLoop.onFrame(this._onFrame);\n    }\n  }\n  /** @internal Called at the end of every animation frame */\n\n\n  _onFrame() {\n    if (Object.keys(this.frame).length) {\n      this._props.onFrame(this.frame);\n\n      this.frame = {};\n    }\n  }\n\n}\n/** Determine which keys should receive an update */\n\n\nfunction extractKeys(props, springs) {\n  const keys = new Set();\n  /** Collect keys with a defined value */\n\n  const getDefinedKeys = obj => each(obj, (value, key) => {\n    if (!is.und(value)) {\n      keys.add(key);\n    }\n  });\n\n  const from = props.from,\n        to = props.to;\n  if (is.obj(to)) getDefinedKeys(to);\n  if (from) getDefinedKeys(from); // When neither \"from\" or \"to\" have a key with a defined value,\n  // return the keys for every existing spring.\n\n  return keys.size ? Array.from(keys) : Object.keys(springs);\n}\n/** @internal */\n\n\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n\n  if (propsFn && arguments.length < 3) {\n    deps = []; // Skip updates after first render.\n  } // The \"ref\" prop is taken from the props of the first spring only.\n  // The ref is assumed to *never* change after the first render.\n\n\n  let ref;\n  const ctrls = useMemo(() => [], []);\n  const updates = [];\n  const prevLength = usePrev(length) || 0;\n  useMemo(() => {\n    if (prevLength > length) {\n      for (let i = length; i < prevLength; i++) {\n        ctrls[i].dispose();\n      }\n    }\n\n    ctrls.length = length;\n\n    for (let i = 0; i < length; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller());\n      const update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        update.default = true;\n\n        if (i == 0 && update.ref) {\n          ref = update.ref;\n        }\n\n        if (i < prevLength) {\n          updates[i] = update;\n        } else {\n          // Update new controllers immediately, so their\n          // spring values exist during first render.\n          ctrl.update(update);\n        }\n      }\n    }\n  }, deps);\n  const api = useMemo$1(() => ({\n    get controllers() {\n      return ctrls;\n    },\n\n    update: props => {\n      each(ctrls, (ctrl, i) => {\n        ctrl.update(getProps(props, i, ctrl));\n        if (!ref) ctrl.start();\n      });\n      return api;\n    },\n\n    async start() {\n      const results = await Promise.all(ctrls.map(ctrl => ctrl.start()));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(ctrls, ctrl => ctrl.stop(keys))\n  }), []);\n  useImperativeHandle(ref, () => api);\n  useIsomorphicLayoutEffect(() => {\n    each(updates, (update, i) => ctrls[i].update(update));\n\n    if (!ref) {\n      each(ctrls, ctrl => ctrl.start());\n    }\n  }, deps);\n  useOnce(() => () => {\n    each(ctrls, ctrl => ctrl.dispose());\n  });\n  const values = ctrls.map(ctrl => ctrl.springs);\n  return propsFn || arguments.length == 3 ? [values, api.update, api.stop] : values;\n}\n/** @internal */\n\n\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n\n  const _useSprings = useSprings(1, isFn ? props : [props], deps),\n        _useSprings$ = _useSprings[0],\n        values = _useSprings$[0],\n        update = _useSprings[1],\n        stop = _useSprings[2];\n\n  return isFn || arguments.length == 3 ? [values, update, stop] : values;\n}\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n\n  if (propsFn && arguments.length < 3) {\n    deps = []; // Skip updates after first render.\n  }\n\n  const ctrls = [];\n  const result = useSprings(length, (i, ctrl) => {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  }, deps);\n  useIsomorphicLayoutEffect(() => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n\n    for (let i = 0; i < ctrls.length; i++) {\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) ctrls[i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n  const update = result[1];\n\n  result[1] = propsArg => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n    return update((i, ctrl) => {\n      const props = getProps(propsArg, i, ctrl);\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) props.to = parent.springs;\n      return props;\n    });\n  };\n\n  return propsFn ? result : result[0];\n}\n/** This transition is being mounted */\n\n\nconst MOUNT = 0;\n/** This transition is entering or has entered */\n\nconst ENTER = 1;\n/** This transition had its animations updated */\n\nconst UPDATE = 2;\n/** This transition will expire after animating */\n\nconst LEAVE = 3;\n\nfunction getKeys(items, _ref) {\n  let key = _ref.key,\n      _ref$keys = _ref.keys,\n      keys = _ref$keys === void 0 ? key : _ref$keys;\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\nfunction useTransition(data, props, deps) {\n  const ref = props.ref,\n        reset = props.reset,\n        sort = props.sort,\n        _props$trail = props.trail,\n        trail = _props$trail === void 0 ? 0 : _props$trail,\n        _props$expires = props.expires,\n        expires = _props$expires === void 0 ? Infinity : _props$expires; // Every item has its own transition.\n\n  const items = toArray(data);\n  const transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  const keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  const usedTransitions = useRef(null);\n  const prevTransitions = usedTransitions.current;\n  useIsomorphicLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  useOnce(() => () => each(usedTransitions.current, t => {\n    if (t.expiresBy != null) {\n      clearTimeout(t.expirationId);\n    }\n\n    t.ctrl.dispose();\n  })); // Map old indices to new indices.\n\n  const reused = [];\n  if (prevTransitions && !reset) each(prevTransitions, (t, i) => {\n    // Expired transitions are not rendered.\n    if (t.expiresBy != null) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  each(items, (item, i) => {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends({}, t, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  } // Track cumulative delay for the \"trail\" prop.\n\n\n  let delay = -trail; // Expired transitions use this to dismount.\n\n  const forceUpdate = useForceUpdate();\n  const defaultProps = {};\n  each(DEFAULT_PROPS, prop => {\n    if (/function|object/.test(typeof props[prop])) {\n      defaultProps[prop] = props[prop];\n    }\n  }); // Generate changes to apply in useEffect.\n\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    let to;\n    let from;\n    let phase;\n\n    if (t.phase == MOUNT) {\n      to = props.enter;\n      phase = ENTER; // The \"initial\" prop is only used on first render. It always overrides\n      // the \"from\" prop when defined, and it makes \"enter\" instant when null.\n\n      from = props.initial;\n\n      if (is.und(from) || prevTransitions && !reset) {\n        from = props.from;\n      }\n    } else {\n      const isLeave = keys.indexOf(t.key) < 0;\n\n      if (t.phase < LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // The payload is used to update the spring props once the current render is committed.\n\n\n    const payload = _extends({}, defaultProps, {\n      // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n      // (2) an async function, or (3) an object with any \"useSpring\" props.\n      to: to = callProp(to, t.item, i),\n      from: callProp(from, t.item, i),\n      delay: delay += trail,\n      config: callProp(props.config || defaultProps.config, t.item, i)\n    }, is.obj(to) && interpolateTo(to));\n\n    const onRest = payload.onRest;\n\n    payload.onRest = result => {\n      if (is.fun(onRest)) {\n        onRest(result);\n      }\n\n      if (t.phase == LEAVE && t.ctrl.idle) {\n        t.expiresBy = now() + expires;\n\n        if (expires <= 0) {\n          forceUpdate();\n        } else {\n          // Postpone dismounts while other controllers are active.\n          const transitions = usedTransitions.current;\n\n          if (transitions.every(t => t.ctrl.idle)) {\n            forceUpdate();\n          } // When `expires` is infinite, postpone dismount until next render.\n          else if (expires < Infinity) {\n              t.expirationId = setTimeout(forceUpdate, expires);\n            }\n        }\n      }\n    };\n\n    const change = {\n      phase\n    };\n    changes.set(t, change); // To ensure all Animated nodes exist during render,\n    // the payload must be applied immediately for new items.\n\n    if (t.phase > MOUNT) {\n      change.payload = payload;\n    } else {\n      t.ctrl.update(payload);\n    }\n  });\n  const api = useMemo$1(() => ({\n    get controllers() {\n      return usedTransitions.current.map(t => t.ctrl);\n    },\n\n    update(props) {\n      each(usedTransitions.current, (t, i) => t.ctrl.update(is.fun(props) ? props(i, t.ctrl) : is.arr(props) ? props[i] : props));\n      return api;\n    },\n\n    async start() {\n      const transitions = usedTransitions.current;\n      const results = await Promise.all(transitions.map(t => t.ctrl.start()));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(usedTransitions.current, t => t.ctrl.stop(keys))\n  }), []);\n  useImperativeHandle(ref, () => api);\n  useIsomorphicLayoutEffect(() => {\n    each(changes, (_ref2, t) => {\n      let phase = _ref2.phase,\n          payload = _ref2.payload;\n      t.phase = phase;\n      if (payload) t.ctrl.update(payload);\n      if (!ref) t.ctrl.start();\n    });\n  }, reset ? void 0 : deps);\n  return render => transitions.map(t => {\n    const elem = render(t.ctrl.springs, t.item, t);\n    return elem && elem.type ? React.createElement(elem.type, Object.assign({}, elem.props, {\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    })) : elem;\n  });\n}\n\nfunction Spring(_ref) {\n  let children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref2) {\n  let items = _ref2.items,\n      children = _ref2.children,\n      props = _objectWithoutPropertiesLoose(_ref2, [\"items\", \"children\"]);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref3) {\n  let items = _ref3.items,\n      children = _ref3.children,\n      props = _objectWithoutPropertiesLoose(_ref3, [\"items\", \"children\"]);\n\n  return useTransition(items, props)(children);\n}\n/** Map the value of one or more dependencies */\n\n\nconst to = function to(source) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return new Into(source, args);\n};\n/** @deprecated Use the `to` export instead */\n\n\nconst interpolate = function interpolate(source) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return deprecateInterpolate(), new Into(source, args);\n};\n\nclass FrameLoop {\n  constructor(_temp) {\n    let _ref = _temp === void 0 ? {} : _temp,\n        update = _ref.update,\n        requestFrame = _ref.requestFrame;\n    /**\r\n     * The animated springs\r\n     */\n\n\n    this.springs = [];\n    /**\r\n     * True when at least one spring is animating.\r\n     */\n\n    this.active = false;\n    /** Equals true when a frame is being processed. */\n\n    this.updating = false;\n    /** Equals true when writing to native attributes. */\n\n    this.writing = false; // These queues are swapped at the end of every frame,\n    // after the current queue is drained.\n\n    this._queues = [new Set(), new Set()];\n    /** `onWrite` callbacks are flushed on every frame, after `onFrame` callbacks are flushed. */\n\n    this._writes = new Set();\n\n    this._requestFrame = // The global `requestAnimationFrame` must be dereferenced to avoid \"Illegal invocation\" errors\n    requestFrame || (fn => (0, requestAnimationFrame)(fn));\n\n    this.update = update && update.bind(this) || (time => {\n      if (!this.active) {\n        return false;\n      }\n\n      if (is.und(time)) {\n        time = performanceNow();\n      }\n\n      let dt = time - this.lastTime;\n\n      if (dt > 0) {\n        // http://gafferongames.com/game-physics/fix-your-timestep/\n        if (dt > 64) dt = 64;\n        this.updating = true;\n        const springs = this.springs;\n        if (springs.length) [...springs].forEach(spring => {\n          spring.idle || this.advance(dt, spring);\n        }); // Notify frame listeners.\n\n        const queues = this._queues;\n        const queue = queues[0];\n\n        if (queue.size) {\n          // Run and clear the queue.\n          queue.forEach(onFrame => onFrame());\n          queue.clear(); // Swap the queues.\n\n          queues[0] = queues[1];\n          queues[1] = queue;\n        }\n\n        const writes = this._writes;\n\n        if (writes.size) {\n          this.writing = true;\n          writes.forEach(write => write(time));\n          this.writing = false;\n          writes.clear();\n        }\n\n        this.updating = false;\n\n        if (!this.springs.length) {\n          return this.active = false;\n        }\n      }\n\n      this.lastTime = time;\n\n      this._requestFrame(this.update);\n\n      return true;\n    });\n  }\n  /**\r\n   * Schedule a function to run at the end of the current frame,\r\n   * after all springs have been updated.\r\n   *\r\n   * Pass `true` as the 2nd argument to run at the end of the **next** frame.\r\n   */\n\n\n  onFrame(cb, next) {\n    this._queues[next && this.updating ? 1 : 0].add(cb);\n\n    this._start();\n  }\n  /**\r\n   * Schedule a function run at the end of the current frame,\r\n   * after all `onFrame` callbacks have been called.\r\n   *\r\n   * Calling `onWrite` from inside an `onWrite` callback simply\r\n   * calls the nested write immediately.\r\n   */\n\n\n  onWrite(cb) {\n    if (this.writing) {\n      cb(this.lastTime);\n    } else {\n      this._writes.add(cb);\n    }\n  }\n  /**\r\n   * Start animating the given spring.\r\n   *\r\n   * Beware: Never `start` the same spring twice (without `stop` between).\r\n   */\n\n\n  start(spring) {\n    const springs = this.springs;\n    let i = springs.findIndex(s => s.priority > spring.priority);\n    if (i < 0) i = springs.length;\n    springs.splice(i, 0, spring);\n\n    this._start();\n  }\n\n  _start() {\n    if (!this.active) {\n      this.active = true;\n      this.lastTime = performanceNow();\n\n      this._requestFrame(this.update);\n    }\n  }\n  /**\r\n   * Stop animating the given spring\r\n   */\n\n\n  stop(spring) {\n    const springs = this.springs;\n    const i = springs.indexOf(spring);\n    if (~i) springs.splice(i, 1);\n    return this;\n  }\n  /**\r\n   * Advance an animation forward one frame.\r\n   */\n\n\n  advance(dt, spring) {\n    let idle = true;\n    let changed = false;\n    const anim = spring.animation;\n    const parent = isFluidValue(anim.to) && anim.to;\n    const payload = isAnimationValue(parent) && parent.node.getPayload();\n    anim.values.forEach((node, i) => {\n      if (node.done) return;\n      let to = payload ? payload[i].lastPosition : parent ? toArray(parent.get())[i] : anim.toValues[i]; // Parent springs must finish before their children can.\n\n      const canFinish = !payload || payload[i].done; // Jump to end value for immediate animations.\n\n      if (anim.immediate) {\n        node.done = canFinish;\n\n        if (node.setValue(to)) {\n          changed = true;\n        }\n\n        return;\n      }\n\n      const config = anim.config; // Loose springs never move.\n\n      if (config.tension == 0) {\n        node.done = true;\n        return;\n      }\n\n      const elapsed = node.elapsedTime += dt;\n      const from = anim.fromValues[i];\n      const v0 = node.v0 != null ? node.v0 : node.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n      let position = node.lastPosition;\n      let velocity;\n      let finished; // Duration easing\n\n      if (!is.und(config.duration)) {\n        let p = config.progress;\n        if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n        position = from + config.easing(p) * (to - from);\n        velocity = (position - node.lastPosition) / dt;\n        finished = p == 1;\n      } // Decay easing\n      else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay;\n          const e = Math.exp(-(1 - decay) * elapsed);\n          position = from + v0 / (1 - decay) * (1 - e); // derivative of position\n\n          velocity = v0 * e;\n          finished = Math.abs(node.lastPosition - position) < 0.1;\n          if (finished) to = position;\n        } // Spring easing\n        else {\n            velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n            /** The smallest distance from a value before being treated like said value. */\n\n            const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n            /** The velocity at which movement is essentially none */\n\n            const restVelocity = config.restVelocity || precision; // Bouncing is opt-in (not to be confused with overshooting)\n\n            const bounceFactor = config.clamp ? 0 : config.bounce;\n            const canBounce = !is.und(bounceFactor);\n            /** When `true`, the value is increasing over time */\n\n            const isGrowing = from == to ? node.v0 > 0 : from < to;\n            /** When `true`, the velocity is considered moving */\n\n            let isMoving;\n            /** When `true`, the velocity is being deflected or clamped */\n\n            let isBouncing = false;\n            const step = 0.05 / config.w0;\n            const numSteps = Math.ceil(dt / step);\n\n            for (let n = 0; n < numSteps; ++n) {\n              isMoving = Math.abs(velocity) > restVelocity;\n\n              if (!isMoving) {\n                finished = Math.abs(to - position) <= precision;\n\n                if (finished) {\n                  break;\n                }\n              }\n\n              if (canBounce) {\n                isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n                if (isBouncing) {\n                  velocity = -velocity * bounceFactor;\n                  position = to;\n                }\n              }\n\n              const springForce = -config.tension * 0.000001 * (position - to);\n              const dampingForce = -config.friction * 0.001 * velocity;\n              const acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n              velocity = velocity + acceleration * step; // pt/ms\n\n              position = position + velocity * step;\n            }\n          }\n\n      if (Number.isNaN(position)) {\n        throw Error(`Found NaN value while advancing \"${spring.key}\" animation`);\n      }\n\n      if (finished && canFinish) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      node.lastVelocity = velocity;\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n    spring.onFrame(idle, changed);\n  }\n\n}\n\nGlobals.assign({\n  frameLoop: new FrameLoop(),\n  createStringInterpolator: createStringInterpolator$1,\n  applyAnimatedValues: () => false\n});\n/** Advance all animations forward one frame */\n\nconst update = () => Globals.frameLoop.update();\n\nexport { Controller, FrameLoop, Spring, SpringValue, Trail, Transition, config, interpolate, to, update, useChain, useSpring, useSprings, useTrail, useTransition };","map":null,"metadata":{},"sourceType":"module"}