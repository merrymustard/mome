{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = require(\"react\");\n\nvar G = __importStar(require(\"./globals\"));\n\nexports.FluidType = '__$FluidType';\n/** Let the given object be observed by any `FluidObserver` */\n\nexports.makeFluidValue = function (value) {\n  return Object.defineProperty(value, exports.FluidType, {\n    value: 1,\n    writable: true\n  });\n};\n\nexports.isFluidValue = function (value) {\n  return (value && value[exports.FluidType]) > 0;\n};\n\nexports.defineHidden = function (obj, key, value) {\n  return Object.defineProperty(obj, key, {\n    value: value,\n    writable: true,\n    configurable: true\n  });\n};\n\nexports.is = {\n  arr: Array.isArray,\n  obj: function obj(a) {\n    return !!a && a.constructor.name === 'Object';\n  },\n  fun: function fun(a) {\n    return typeof a === 'function';\n  },\n  str: function str(a) {\n    return typeof a === 'string';\n  },\n  num: function num(a) {\n    return typeof a === 'number';\n  },\n  und: function und(a) {\n    return a === undefined;\n  }\n};\n/** Compare animatable values */\n\nfunction isEqual(a, b) {\n  if (exports.is.arr(a)) {\n    if (!exports.is.arr(b) || a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  }\n\n  return a === b;\n}\n\nexports.isEqual = isEqual; // Not all strings can be animated (eg: {display: \"none\"})\n\nexports.needsInterpolation = function (value) {\n  return exports.is.str(value) && (value[0] == '#' || /\\d/.test(value) || !!(G.colorNames && G.colorNames[value]));\n};\n/** An unsafe object/array/set iterator that allows for better minification */\n\n\nexports.each = function (obj, cb, ctx) {\n  if (exports.is.fun(obj.forEach)) {\n    obj.forEach(cb, ctx);\n  } else {\n    Object.keys(obj).forEach(function (key) {\n      return cb.call(ctx, obj[key], key);\n    });\n  }\n};\n\nexports.toArray = function (a) {\n  return exports.is.und(a) ? [] : exports.is.arr(a) ? a : [a];\n};\n\nexports.useOnce = function (effect) {\n  return react_1.useEffect(effect, []);\n};\n\nexports.useForceUpdate = function () {\n  return react_1.useReducer(function () {\n    return {};\n  }, 0)[1];\n};\n/** Use a value from the previous render */\n\n\nfunction usePrev(value) {\n  var prevRef = react_1.useRef(undefined);\n  react_1.useEffect(function () {\n    prevRef.current = value;\n  });\n  return prevRef.current;\n}\n\nexports.usePrev = usePrev;\n/**\n * React calls `console.warn` when using `useLayoutEffect` on the server.\n * To get around it, we can conditionally `useEffect` on the server (no-op) and\n * `useLayoutEffect` on the client.\n */\n\nexports.useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? react_1.useLayoutEffect : react_1.useEffect;","map":null,"metadata":{},"sourceType":"script"}