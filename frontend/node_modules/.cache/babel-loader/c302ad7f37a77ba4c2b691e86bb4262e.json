{"ast":null,"code":"import _assertThisInitialized from \"/Users/mariasantosmoises/Documents/Ironhack/mome/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _toConsumableArray from \"/Users/mariasantosmoises/Documents/Ironhack/mome/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _get from \"/Users/mariasantosmoises/Documents/Ironhack/mome/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _possibleConstructorReturn from \"/Users/mariasantosmoises/Documents/Ironhack/mome/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mariasantosmoises/Documents/Ironhack/mome/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mariasantosmoises/Documents/Ironhack/mome/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/Users/mariasantosmoises/Documents/Ironhack/mome/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mariasantosmoises/Documents/Ironhack/mome/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { defineHidden, FluidType, is, each, isFluidValue, createInterpolator, toArray, isEqual, Globals, needsInterpolation, useForceUpdate, useIsomorphicLayoutEffect } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport { to as _to2, createAnimatedTransform, createAnimatedStyle, frameLoop, applyAnimatedValues, getComponentProps } from '@react-spring/shared/globals';\nimport { createInterpolator as createInterpolator$1, is as is$1 } from '@react-spring/shared';\nimport React, { forwardRef, useRef } from 'react';\nvar AnimatedType = '__$AnimatedType';\n/** Returns true for `Animated` nodes. Returns false for `SpringValue` objects. */\n\nvar isAnimated = function isAnimated(value) {\n  return !!(value && value[AnimatedType]);\n};\n\nvar Animated =\n/*#__PURE__*/\nfunction () {\n  function Animated() {\n    _classCallCheck(this, Animated);\n\n    defineHidden(this, AnimatedType, 1);\n  }\n  /** Returns every animated number used by this node. */\n\n\n  _createClass(Animated, [{\n    key: \"getPayload\",\n    value: function getPayload() {\n      return this.payload || [];\n    }\n  }]);\n\n  return Animated;\n}();\n/** The `AnimatedProps` class sets this before initializing */\n\n\nAnimated.context = null;\n\nvar isAnimationValue = function isAnimationValue(value) {\n  return (value && value[FluidType]) == 2;\n};\n\nvar nextId = 1;\n/**\r\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\r\n *\r\n * Its underlying value can be accessed and even observed.\r\n */\n\nvar AnimationValue =\n/*#__PURE__*/\nfunction () {\n  function AnimationValue(key) {\n    _classCallCheck(this, AnimationValue);\n\n    this.key = key;\n    this.id = nextId++;\n    this._priority = 0;\n    this._children = new Set();\n    defineHidden(this, FluidType, 2);\n  }\n  /** @internal Controls the order in which animations are updated */\n\n\n  _createClass(AnimationValue, [{\n    key: \"get\",\n\n    /** Get the current value */\n    value: function get() {\n      // The node doesn't exist until the first update, which normally isn't an\n      // issue but it can be for tests.\n      return this.node && this.node.getValue();\n    }\n    /** Create a spring that maps our value to another value */\n\n  }, {\n    key: \"to\",\n    value: function to() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _to2(this, args);\n    }\n    /** @deprecated Use the `to` method instead. */\n\n  }, {\n    key: \"interpolate\",\n    value: function interpolate() {\n      deprecateInterpolate();\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _to2(this, args);\n    }\n    /** @internal */\n\n  }, {\n    key: \"addChild\",\n    value: function addChild(child) {\n      if (!this._children.size) this._attach();\n\n      this._children.add(child);\n    }\n    /** @internal */\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      this._children.delete(child);\n\n      if (!this._children.size) this._detach();\n    }\n    /** @internal */\n\n  }, {\n    key: \"onParentPriorityChange\",\n    value: function onParentPriorityChange(priority, _parent) {\n      // Assume we only have one parent.\n      this.priority = priority + 1;\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach() {}\n  }, {\n    key: \"_detach\",\n    value: function _detach() {}\n    /** Notify observers of a change to our value */\n\n  }, {\n    key: \"_onChange\",\n    value: function _onChange(value, idle) {\n      if (idle === void 0) {\n        idle = false;\n      } // Clone \"_children\" so it can be safely mutated by the loop.\n\n\n      for (var _i = 0, _Array$from = Array.from(this._children); _i < _Array$from.length; _i++) {\n        var observer = _Array$from[_i];\n\n        if (is.fun(observer)) {\n          observer(value, this);\n        } else {\n          observer.onParentChange(value, idle, this);\n        }\n      }\n    }\n    /** Notify observers of a change to our priority */\n\n  }, {\n    key: \"_onPriorityChange\",\n    value: function _onPriorityChange(priority) {\n      var _this = this;\n\n      each(this._children, function (observer) {\n        if (!is.fun(observer)) {\n          observer.onParentPriorityChange(priority, _this);\n        }\n      });\n    }\n    /** Reset our node and the nodes of every descendant */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset(goal) {\n      this.node.reset(!this.idle, goal);\n      each(this._children, function (observer) {\n        if (isAnimationValue(observer)) {\n          observer._reset(goal);\n        }\n      });\n    }\n  }, {\n    key: \"priority\",\n    get: function get() {\n      return this._priority;\n    },\n    set: function set(priority) {\n      if (this._priority != priority) {\n        this._priority = priority;\n\n        this._onPriorityChange(priority);\n      }\n    }\n  }]);\n\n  return AnimationValue;\n}();\n/** An object containing `Animated` nodes */\n\n\nvar AnimatedObject =\n/*#__PURE__*/\nfunction (_Animated) {\n  _inherits(AnimatedObject, _Animated);\n\n  function AnimatedObject(source) {\n    var _this2;\n\n    _classCallCheck(this, AnimatedObject);\n\n    if (source === void 0) {\n      source = null;\n    }\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedObject).call(this));\n\n    _this2.setValue(source);\n\n    return _this2;\n  }\n\n  _createClass(AnimatedObject, [{\n    key: \"getValue\",\n    value: function getValue(animated) {\n      if (!this.source) return null;\n      var values = {};\n      each(this.source, function (source, key) {\n        if (isAnimated(source)) {\n          values[key] = source.getValue(animated);\n        } else if (isFluidValue(source)) {\n          values[key] = source.get();\n        } else if (!animated) {\n          values[key] = source;\n        }\n      });\n      return values;\n    }\n    /** Replace the raw object data */\n\n  }, {\n    key: \"setValue\",\n    value: function setValue(source) {\n      this.source = source;\n      this.payload = this._makePayload(source);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(isActive, _goal) {\n      if (this.payload) {\n        each(this.payload, function (node) {\n          return node.reset(isActive);\n        });\n      }\n    }\n    /** Create a payload set. */\n\n  }, {\n    key: \"_makePayload\",\n    value: function _makePayload(source) {\n      if (source) {\n        var payload = new Set();\n        each(source, this._addToPayload, payload);\n        return Array.from(payload);\n      }\n    }\n    /** Add to a payload set. */\n\n  }, {\n    key: \"_addToPayload\",\n    value: function _addToPayload(source) {\n      var _this3 = this;\n\n      if (isFluidValue(source)) {\n        if (Animated.context) {\n          Animated.context.dependencies.add(source);\n        }\n\n        if (isAnimationValue(source)) {\n          source = source.node;\n        }\n      }\n\n      if (isAnimated(source)) {\n        each(source.getPayload(), function (node) {\n          return _this3.add(node);\n        });\n      }\n    }\n  }]);\n\n  return AnimatedObject;\n}(Animated);\n\nvar AnimatedStyle =\n/*#__PURE__*/\nfunction (_AnimatedObject) {\n  _inherits(AnimatedStyle, _AnimatedObject);\n\n  function AnimatedStyle(style) {\n    _classCallCheck(this, AnimatedStyle);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AnimatedStyle).call(this, style || null));\n  }\n\n  _createClass(AnimatedStyle, [{\n    key: \"setValue\",\n    value: function setValue(style) {\n      _get(_getPrototypeOf(AnimatedStyle.prototype), \"setValue\", this).call(this, style && style.transform && createAnimatedTransform ? _extends({}, style, {\n        transform: createAnimatedTransform(style.transform)\n      }) : style);\n    }\n  }]);\n\n  return AnimatedStyle;\n}(AnimatedObject);\n/** An animated number or a native attribute value */\n\n\nvar AnimatedValue =\n/*#__PURE__*/\nfunction (_Animated2) {\n  _inherits(AnimatedValue, _Animated2);\n\n  function AnimatedValue(_value) {\n    var _this4;\n\n    _classCallCheck(this, AnimatedValue);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedValue).call(this));\n    _this4._value = _value;\n    _this4.done = true;\n\n    if (is.num(_this4._value)) {\n      _this4.lastPosition = _this4._value;\n    }\n\n    return _this4;\n  }\n\n  _createClass(AnimatedValue, [{\n    key: \"getPayload\",\n    value: function getPayload() {\n      return [this];\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this._value;\n    }\n    /**\r\n     * Set the current value and optionally round it.\r\n     *\r\n     * The `step` argument does nothing whenever it equals `undefined` or `0`.\r\n     * It works with fractions and whole numbers. The best use case is (probably)\r\n     * rounding to the pixel grid with a step of:\r\n     *\r\n     *      1 / window.devicePixelRatio\r\n     */\n\n  }, {\n    key: \"setValue\",\n    value: function setValue(value, step) {\n      if (is.num(value)) {\n        this.lastPosition = value;\n\n        if (step) {\n          value = Math.round(value / step) * step;\n\n          if (this.done) {\n            this.lastPosition = value;\n          }\n        }\n      }\n\n      if (this._value === value) {\n        return false;\n      }\n\n      this._value = value;\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(isActive, _goal) {\n      this.done = false;\n\n      if (is.num(this._value)) {\n        this.elapsedTime = 0;\n        this.lastPosition = this._value;\n        if (!isActive) this.lastVelocity = null;\n        this.v0 = null;\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(from, _to) {\n      return new AnimatedValue(from);\n    }\n  }]);\n\n  return AnimatedValue;\n}(Animated);\n/**\r\n * `Into` springs are memoized interpolators that react to their dependencies.\r\n *  The memoized result is updated whenever a dependency changes.\r\n */\n\n\nvar Into =\n/*#__PURE__*/\nfunction (_AnimationValue) {\n  _inherits(Into, _AnimationValue);\n\n  function Into(\n  /** The source of input values */\n  source, args) {\n    var _this5;\n\n    _classCallCheck(this, Into);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(Into).call(this));\n    _this5.source = source;\n    _this5.calc = createInterpolator.apply(void 0, _toConsumableArray(args));\n    _this5.node = new AnimatedValue(_this5._compute());\n    return _this5;\n  }\n\n  _createClass(Into, [{\n    key: \"_compute\",\n    value: function _compute() {\n      var inputs = is.arr(this.source) ? this.source.map(function (node) {\n        return node.get();\n      }) : toArray(this.source.get());\n      return this.calc.apply(this, _toConsumableArray(inputs));\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach() {\n      var _this6 = this;\n\n      // Start observing our \"source\" once we have an observer.\n      var priority = 0;\n      each(toArray(this.source), function (source) {\n        priority = Math.max(priority, (source.priority || 0) + 1);\n        source.addChild(_this6);\n      });\n      this.priority = priority;\n    }\n  }, {\n    key: \"_detach\",\n    value: function _detach() {\n      var _this7 = this;\n\n      // Stop observing our \"source\" once we have no observers.\n      each(toArray(this.source), function (source) {\n        source.removeChild(_this7);\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"onParentChange\",\n    value: function onParentChange(_value, idle) {\n      var node = this.node;\n\n      if (idle && !node.done) {\n        // We're not idle until every source is idle.\n        node.done = toArray(this.source).every(function (source) {\n          return !isAnimationValue(source) || source.idle;\n        });\n      } // TODO: only compute once per frame (note: we'll need to call \"onParentChange\")\n\n\n      var value = this._compute();\n\n      if (!isEqual(value, this.get())) {\n        node.setValue(value);\n\n        this._onChange(value, node.done);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"onParentPriorityChange\",\n    value: function onParentPriorityChange(_priority) {\n      // Set our priority to 1 + the highest parent.\n      this.priority = toArray(this.source).reduce(function (max, source) {\n        return Math.max(max, (source.priority || 0) + 1);\n      }, 0);\n    }\n  }, {\n    key: \"idle\",\n    get: function get() {\n      return this.node.done;\n    }\n  }]);\n\n  return Into;\n}(AnimationValue);\n\nGlobals.assign({\n  to: function to(source, args) {\n    return new Into(source, args);\n  },\n  createAnimatedStyle: function createAnimatedStyle(style) {\n    return new AnimatedStyle(style);\n  }\n});\n\nvar AnimatedString =\n/*#__PURE__*/\nfunction (_AnimatedValue) {\n  _inherits(AnimatedString, _AnimatedValue);\n\n  function AnimatedString(from, to) {\n    var _this8;\n\n    _classCallCheck(this, AnimatedString);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedString).call(this, 0));\n    _this8._string = null;\n    _this8._toString = createInterpolator$1({\n      output: [from, to]\n    });\n    return _this8;\n  }\n\n  _createClass(AnimatedString, [{\n    key: \"getValue\",\n    value: function getValue() {\n      var value = this._string;\n      return value == null ? this._string = this._toString(this._value) : value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      if (!is$1.num(value)) {\n        this._string = value;\n        this._value = 1;\n      } else if (_get(_getPrototypeOf(AnimatedString.prototype), \"setValue\", this).call(this, value)) {\n        this._string = null;\n      } else {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(isActive, goal) {\n      if (goal) {\n        this._toString = createInterpolator$1({\n          output: [this.getValue(), goal]\n        });\n      }\n\n      this._value = 0;\n\n      _get(_getPrototypeOf(AnimatedString.prototype), \"reset\", this).call(this, isActive);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(from, to) {\n      if (to === void 0) {\n        to = from;\n      }\n\n      if (is$1.str(from) && is$1.str(to)) {\n        return new AnimatedString(from, to);\n      }\n\n      throw TypeError('Expected \"from\" and \"to\" to be strings');\n    }\n  }]);\n\n  return AnimatedString;\n}(AnimatedValue);\n/** An array of animated nodes */\n\n\nvar AnimatedArray =\n/*#__PURE__*/\nfunction (_AnimatedObject2) {\n  _inherits(AnimatedArray, _AnimatedObject2);\n\n  function AnimatedArray(from, to) {\n    var _this9;\n\n    _classCallCheck(this, AnimatedArray);\n\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedArray).call(this, null));\n\n    _get(_getPrototypeOf(AnimatedArray.prototype), \"setValue\", _assertThisInitialized(_this9)).call(_assertThisInitialized(_this9), _this9._makeAnimated(from, to));\n\n    return _this9;\n  }\n\n  _createClass(AnimatedArray, [{\n    key: \"getValue\",\n    value: function getValue() {\n      return this.source.map(function (node) {\n        return node.getValue();\n      });\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(newValue) {\n      var payload = this.getPayload(); // Reuse the payload when lengths are equal.\n\n      if (newValue && newValue.length == payload.length) {\n        each(payload, function (node, i) {\n          return node.setValue(newValue[i]);\n        });\n      } else {\n        // Remake the payload when length changes.\n        this.source = this._makeAnimated(newValue);\n        this.payload = this._makePayload(this.source);\n      }\n    }\n    /** Convert the `from` and `to` values to an array of `Animated` nodes */\n\n  }, {\n    key: \"_makeAnimated\",\n    value: function _makeAnimated(from, to) {\n      if (to === void 0) {\n        to = from;\n      }\n\n      return from ? from.map(function (from, i) {\n        return (needsInterpolation(from) ? AnimatedString : AnimatedValue).create(from, to[i]);\n      }) : [];\n    }\n  }], [{\n    key: \"create\",\n    value: function create(from, to) {\n      return new AnimatedArray(from, to);\n    }\n  }]);\n\n  return AnimatedArray;\n}(AnimatedObject);\n\nvar AnimatedProps =\n/*#__PURE__*/\nfunction (_AnimatedObject3) {\n  _inherits(AnimatedProps, _AnimatedObject3);\n\n  function AnimatedProps(update) {\n    var _this10;\n\n    _classCallCheck(this, AnimatedProps);\n\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedProps).call(this, null));\n    _this10.update = update;\n    /** Equals true when a re-render is scheduled for \"end of frame\" */\n\n    _this10.dirty = false;\n    return _this10;\n  }\n\n  _createClass(AnimatedProps, [{\n    key: \"setValue\",\n    value: function setValue(props, context) {\n      if (!props) return; // The constructor passes null.\n\n      if (context) {\n        Animated.context = context;\n      }\n\n      _get(_getPrototypeOf(AnimatedProps.prototype), \"setValue\", this).call(this, props.style && createAnimatedStyle ? _extends({}, props, {\n        style: createAnimatedStyle(props.style)\n      }) : props);\n\n      Animated.context = null;\n    }\n    /** @internal */\n\n  }, {\n    key: \"onParentChange\",\n    value: function onParentChange() {\n      var _this11 = this;\n\n      if (!this.dirty) {\n        this.dirty = true;\n        frameLoop.onFrame(function () {\n          _this11.dirty = false;\n\n          _this11.update();\n        });\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"onParentPriorityChange\",\n    value: function onParentPriorityChange() {}\n  }]);\n\n  return AnimatedProps;\n}(AnimatedObject);\n\nvar cacheKey = Symbol.for('AnimatedComponent');\n\nvar withAnimated = function withAnimated(Component) {\n  return is.str(Component) ? createAnimatedComponent(Component) : Component[cacheKey] || (Component[cacheKey] = createAnimatedComponent(Component));\n};\n\nvar createAnimatedComponent = function createAnimatedComponent(Component) {\n  return forwardRef(function (rawProps, ref) {\n    var instanceRef = useRef(null);\n    var hasInstance = // Function components must use \"forwardRef\" to avoid being\n    // re-rendered on every animation frame.\n    !is.fun(Component) || Component.prototype.isReactComponent;\n    var forceUpdate = useForceUpdate();\n    var props = new AnimatedProps(function () {\n      var instance = instanceRef.current;\n\n      if (hasInstance && !instance) {\n        return; // The wrapped component forgot to forward its ref.\n      }\n\n      var didUpdate = instance ? applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.\n\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    });\n    var dependencies = new Set();\n    props.setValue(rawProps, {\n      dependencies: dependencies\n    });\n    useIsomorphicLayoutEffect(function () {\n      each(dependencies, function (dep) {\n        return dep.addChild(props);\n      });\n      return function () {\n        return each(dependencies, function (dep) {\n          return dep.removeChild(props);\n        });\n      };\n    });\n    return React.createElement(Component, Object.assign({}, getComponentProps(props.getValue()), {\n      ref: hasInstance && function (value) {\n        instanceRef.current = updateRef(ref, value);\n      }\n    }));\n  });\n};\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n/**\r\n * Pass the given components to `withAnimated` and add the newly animated\r\n * components to `withAnimated` as properties.\r\n */\n\n\nvar extendAnimated = function extendAnimated(withAnimated, components, lowercase) {\n  components.forEach(function (Component) {\n    var key = getDisplayName(Component);\n\n    if (lowercase) {\n      key = key[0].toLowerCase() + key.slice(1);\n    }\n\n    withAnimated[key] = withAnimated(Component);\n  });\n  return withAnimated;\n};\n\nvar getDisplayName = function getDisplayName(arg) {\n  return is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n};\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedStyle, AnimatedType, AnimatedValue, AnimationValue, Into, extendAnimated, isAnimated, isAnimationValue, withAnimated };","map":null,"metadata":{},"sourceType":"module"}