import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import React, { useContext, useState, useEffect, useRef } from 'react';
import { defaultElement, frameLoop } from '@react-spring/shared/globals';
import { Controller, config } from '@react-spring/core';
import { withAnimated } from '@react-spring/animated';
import { useMemoOne } from 'use-memo-one';
import { useOnce } from '@react-spring/shared';

const AnimatedView = withAnimated(defaultElement);
const ParentContext = React.createContext(null);

function getScrollType(horizontal) {
  return horizontal ? 'scrollLeft' : 'scrollTop';
}

const START_TRANSLATE_3D = 'translate3d(0px,0px,0px)';
const START_TRANSLATE = 'translate(0px,0px)';
const ParallaxLayer = React.memo((_ref) => {
  let horizontal = _ref.horizontal,
      _ref$factor = _ref.factor,
      factor = _ref$factor === void 0 ? 1 : _ref$factor,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? 0 : _ref$offset,
      _ref$speed = _ref.speed,
      speed = _ref$speed === void 0 ? 0 : _ref$speed,
      rest = _objectWithoutPropertiesLoose(_ref, ["horizontal", "factor", "offset", "speed"]);

  // Our parent controls our height and position.
  const parent = useContext(ParentContext); // This is how we animate.

  const ctrl = useMemoOne(() => {
    const targetScroll = Math.floor(offset) * parent.space;
    const distance = parent.space * offset + targetScroll * speed;
    return new Controller({
      space: parent.space * factor,
      translate: -(parent.current * speed) + distance
    });
  }, []); // Create the layer.

  const layer = useMemoOne(() => ({
    setPosition(height, scrollTop, immediate) {
      if (immediate === void 0) {
        immediate = false;
      }

      const targetScroll = Math.floor(offset) * height;
      const distance = height * offset + targetScroll * speed;
      ctrl.start({
        translate: -(scrollTop * speed) + distance,
        config: parent.config,
        immediate
      });
    },

    setHeight(height, immediate) {
      if (immediate === void 0) {
        immediate = false;
      }

      ctrl.start({
        space: height * factor,
        config: parent.config,
        immediate
      });
    }

  }), []); // Register the layer with our parent.

  useOnce(() => {
    if (parent) {
      parent.layers.add(layer);
      parent.update();
      return () => {
        parent.layers.delete(layer);
        parent.update();
      };
    }
  });
  const translate3d = ctrl.get('translate').to(horizontal ? x => `translate3d(${x}px,0,0)` : y => `translate3d(0,${y}px,0)`);
  return React.createElement(AnimatedView, Object.assign({}, rest, {
    style: _extends({
      position: 'absolute',
      backgroundSize: 'auto',
      backgroundRepeat: 'no-repeat',
      willChange: 'transform',
      [horizontal ? 'height' : 'width']: '100%',
      [horizontal ? 'width' : 'height']: ctrl.get('space'),
      WebkitTransform: translate3d,
      MsTransform: translate3d,
      transform: translate3d
    }, rest.style)
  }));
  return null;
});
const Parallax = React.memo((_ref2) => {
  let pages = _ref2.pages,
      _ref2$config = _ref2.config,
      config$1 = _ref2$config === void 0 ? config.slow : _ref2$config,
      _ref2$enabled = _ref2.enabled,
      enabled = _ref2$enabled === void 0 ? true : _ref2$enabled,
      _ref2$horizontal = _ref2.horizontal,
      horizontal = _ref2$horizontal === void 0 ? false : _ref2$horizontal,
      innerStyle = _ref2.innerStyle,
      rest = _objectWithoutPropertiesLoose(_ref2, ["pages", "config", "enabled", "horizontal", "innerStyle"]);

  const _useState = useState(false),
        ready = _useState[0],
        setReady = _useState[1];

  let state;
  state = useMemoOne(() => ({
    config: config$1,
    busy: false,
    space: 0,
    current: 0,
    offset: 0,
    controller: new Controller({
      scroll: 0
    }),
    layers: new Set(),
    update: () => _update(),
    scrollTo: offset => _scrollTo(offset),
    stop: () => state.controller.stop()
  }), []);
  useEffect(() => {
    state.config = config$1;
  }, [config$1]);
  const containerRef = useRef();
  const contentRef = useRef();

  const _update = () => {
    const container = containerRef.current;
    if (!container) return;
    const spaceProp = horizontal ? 'clientWidth' : 'clientHeight';
    state.space = container[spaceProp];
    const scrollType = getScrollType(horizontal);

    if (enabled) {
      state.current = container[scrollType];
    } else {
      container[scrollType] = state.current = state.offset * state.space;
    }

    const content = contentRef.current;

    if (content) {
      const sizeProp = horizontal ? 'width' : 'height';
      content.style[sizeProp] = `${state.space * pages}px`;
    }

    state.layers.forEach(layer => {
      layer.setHeight(state.space, true);
      layer.setPosition(state.space, state.current, true);
    });
  };

  const _scrollTo = offset => {
    const container = containerRef.current;
    const scrollType = getScrollType(horizontal);
    state.offset = offset;
    state.controller.stop().start({
      scroll: offset * state.space,
      config: config$1,

      onFrame(_ref3) {
        let scroll = _ref3.scroll;
        container[scrollType] = scroll;
      }

    });
  };

  const onScroll = event => {
    if (!state.busy) {
      state.busy = true;
      state.current = event.target[getScrollType(horizontal)];
      frameLoop.onFrame(() => {
        state.layers.forEach(layer => layer.setPosition(state.space, state.current));
        state.busy = false;
      });
    }
  };

  useEffect(() => state.update());
  useOnce(() => {
    setReady(true);

    const onResize = () => {
      const update = () => state.update();

      frameLoop.onFrame(update);
      setTimeout(update, 150); // Some browsers don't fire on maximize!
    };

    window.addEventListener('resize', onResize, false);
    return () => window.removeEventListener('resize', onResize, false);
  });
  const overflow = enabled ? 'scroll' : 'hidden';
  return React.createElement(defaultElement, Object.assign({}, rest, {
    ref: containerRef,
    onScroll: onScroll,
    onWheel: enabled ? state.stop : null,
    onTouchStart: enabled ? state.stop : null,
    style: _extends({
      position: 'absolute',
      width: '100%',
      height: '100%',
      overflow,
      overflowY: horizontal ? 'hidden' : overflow,
      overflowX: horizontal ? overflow : 'hidden',
      WebkitOverflowScrolling: 'touch',
      WebkitTransform: START_TRANSLATE,
      MsTransform: START_TRANSLATE,
      transform: START_TRANSLATE_3D
    }, rest.style)
  }), ready && React.createElement(defaultElement, {
    ref: contentRef,
    style: _extends({
      overflow: 'hidden',
      position: 'absolute',
      [horizontal ? 'height' : 'width']: '100%',
      [horizontal ? 'width' : 'height']: state.space * pages,
      WebkitTransform: START_TRANSLATE,
      MsTransform: START_TRANSLATE,
      transform: START_TRANSLATE_3D
    }, innerStyle)
  }, React.createElement(ParentContext.Provider, {
    value: state
  }, rest.children)));
});

export { Parallax, ParallaxLayer };
//# sourceMappingURL=parallax.js.map
