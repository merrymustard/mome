{"version":3,"file":"common.js","sourceRoot":"","sources":["../../src/types/common.ts"],"names":[],"mappings":"","sourcesContent":["export type Indexable<T = any> = { [key: string]: T; [i: number]: T }\n\nexport type OneOrMore<T> = T | readonly T[]\n\n/** Ensure each type of `T` is an array */\nexport type Arrify<T> = [T, T] extends [infer T, infer DT]\n  ? DT extends ReadonlyArray<any>\n    ? Array<DT[number]> extends DT\n      ? ReadonlyArray<T extends ReadonlyArray<infer U> ? U : T>\n      : DT\n    : ReadonlyArray<T extends ReadonlyArray<infer U> ? U : T>\n  : never\n\nexport type Falsy = false | null | undefined\n\nexport type AnyFn<In extends ReadonlyArray<any> = any[], Out = any> = (\n  ...args: In\n) => Out\n\n/** For solving generic types */\nexport type Solve<T> = T\n\n/** For resolving object intersections */\nexport type Remap<T> = Solve<{ [P in keyof T]: T[P] }>\n\n/** Override the property types of `A` with `B` and merge any new properties */\nexport type Merge<A, B> = { [P in keyof A]: P extends keyof B ? B[P] : A[P] } &\n  Omit<B, keyof A>\n\n/** Same as `Merge<A, B>` except the property descriptions from `B` override those of `A` */\nexport type Overwrite<A, B> = Omit<A, keyof B> & B\n\n/** An object partial with the same type for every value */\nexport type KeyedPartial<K extends string | number, T> = {\n  [P in K]?: T\n}\n\n/** Return the keys of `T` with values that are assignable to `U` */\nexport type AssignableKeys<T, U> = T extends object\n  ? U extends object\n    ? {\n        [P in Extract<keyof T, keyof U>]: T[P] extends U[P] ? P : never\n      }[Extract<keyof T, keyof U>]\n    : never\n  : never\n\n/** Give \"any\" its own class */\nexport declare class Any {\n  _: never\n}\n\n/** Better type errors for overloads with generic types */\nexport type Constrain<T, U> = [T] extends [Any] ? U : [T] extends [U] ? T : U\n\n/** Ensure the given type is an object type */\nexport type ObjectType<T> = T extends {} ? T : {}\n\n/** Intersected with other object types to allow for unknown properties */\nexport type UnknownProps = Indexable<unknown>\n\nexport type UnknownPartial<T> = UnknownProps & Partial<T>\n\n/** Extract string keys from an object type */\nexport type StringKeys<T> = T extends object ? Extract<keyof T, string> : string\n\n// https://github.com/microsoft/TypeScript/issues/14829#issuecomment-504042546\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\n/** Intersect a union of objects but merge property types with _unions_ */\nexport type ObjectFromUnion<T extends object> = Remap<\n  {\n    [P in keyof Intersect<T>]: T extends infer U\n      ? P extends keyof U\n        ? U[P]\n        : never\n      : never\n  }\n>\n\n/** Convert a union to an intersection */\ntype Intersect<U> = (U extends any ? (k: U) => void : never) extends ((\n  k: infer I\n) => void)\n  ? I\n  : never\n"]}