import { useIsomorphicLayoutEffect, each, is, toArray, isFluidValue, needsInterpolation, isEqual, usePrev, useOnce, useForceUpdate, Globals } from '@react-spring/shared';
export { Globals, createInterpolator, isFluidValue, makeFluidValue } from '@react-spring/shared';
import React, { useMemo as useMemo$1, useImperativeHandle, useRef } from 'react';
import _extends from '@babel/runtime/helpers/esm/extends';
import { frameLoop, createStringInterpolator, now, skipAnimation, requestAnimationFrame, performanceNow } from '@react-spring/shared/globals';
import { useMemoOne } from 'use-memo-one';
import { AnimationValue, isAnimationValue, AnimatedString, AnimatedValue, AnimatedArray, Into } from '@react-spring/animated';
export { AnimationValue, Into, isAnimationValue } from '@react-spring/animated';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { deprecateInterpolate } from '@react-spring/shared/deprecations';
import { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';

/** API
 *  useChain(references, timeSteps, timeFrame)
 */

function useChain(refs, timeSteps, timeFrame) {
  if (timeFrame === void 0) {
    timeFrame = 1000;
  }

  useIsomorphicLayoutEffect(() => {
    if (timeSteps) {
      let prevDelay = 0;
      each(refs, (ref, i) => {
        if (!ref.current) return;
        const controllers = ref.current.controllers;

        if (controllers.length) {
          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.

          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;
          each(controllers, ctrl => {
            each(ctrl.queue, props => {
              props.delay = delay + (props.delay || 0);
            });
            ctrl.start();
          });
        }
      });
    } else {
      let p = Promise.resolve();
      each(refs, ref => {
        const _ref = ref.current || {},
              controllers = _ref.controllers,
              start = _ref.start;

        if (controllers && controllers.length) {
          // Take the queue of each controller
          const updates = controllers.map(ctrl => {
            const q = ctrl.queue;
            ctrl.queue = [];
            return q;
          }); // Apply the queue when the previous ref stops animating

          p = p.then(() => {
            each(controllers, (ctrl, i) => ctrl.queue.push(...updates[i]));
            return start();
          });
        }
      });
    }
  });
}

const useMemo = (create, deps) => useMemoOne(create, deps || [{}]);
function callProp(value) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return is.fun(value) ? value(...args) : value;
}
/** Try to coerce the given value into a boolean using the given key */

const matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
const getProps = (props, i, arg) => is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : _extends({}, props);
/** These props can have default values */

const DEFAULT_PROPS = ['config', 'immediate', 'onAnimate', 'onStart', 'onChange', 'onRest'];
const RESERVED_PROPS = {
  children: 1,
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  reset: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  lazy: 1,
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  leave: 1,
  update: 1,
  onAnimate: 1,
  onStart: 1,
  onRest: 1,
  onChange: 1,
  onFrame: 1
};
/**
 * Extract any properties whose keys are *not* reserved for customizing your
 * animations. All hooks use this function, which means `useTransition` props
 * are reserved for `useSpring` calls, etc.
 */

function getForwardProps(props) {
  const forward = {};
  each(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
    }
  });
  return forward;
}

function interpolateTo(props) {
  const to = getForwardProps(props);
  const out = {
    to
  };
  each(props, (val, key) => key in to || (out[key] = val));
  return out;
}

/**
 * Start an async chain or an async script.
 *
 * You should always wrap `runAsync` calls with `scheduleProps` so that
 * you have access to `RunAsyncProps` instead of the usual `SpringProps`.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */

async function runAsync(to, props, state, getValue, getPaused, update, stop) {
  if (props.cancel) {
    state.asyncTo = undefined;
    return {
      value: getValue(),
      cancelled: true
    };
  } // Wait for the previous async animation to be cancelled.
  else if (props.reset) {
      await state.promise;
    } // Async animations are only replaced when "props.to" changes
    // or when "props.reset" equals true.
    else if (to === state.asyncTo) {
        return state.promise;
      }

  state.asyncTo = to;
  return state.promise = (async () => {
    const asyncId = props.asyncId;
    const cancelToken = Symbol.for('cancel');

    const isCancelled = () => to !== state.asyncTo || asyncId <= (state.cancelId || 0);

    const defaultProps = {};
    each(DEFAULT_PROPS, prop => {
      if (prop == 'onRest') return;

      if (/function|object/.test(typeof props[prop])) {
        defaultProps[prop] = props[prop];
      }
    });

    const animate = (arg1, arg2) => {
      if (isCancelled()) {
        throw cancelToken;
      }

      const props = is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {
        to: arg1
      });
      each(defaultProps, (value, prop) => {
        if (is.und(props[prop])) {
          props[prop] = value;
        }
      });
      const parentTo = state.asyncTo;
      return update(props).then(async result => {
        if (state.asyncTo == null) {
          state.asyncTo = parentTo;
        }

        if (isCancelled()) {
          throw cancelToken;
        }

        if (getPaused()) {
          await new Promise(resolve => {
            state.unpause = resolve;
          });
          state.unpause = undefined;
        }

        return result;
      });
    };

    let result;

    try {
      // Async sequence
      if (is.arr(to)) {
        for (const props of to) {
          await animate(props);
        }
      } // Async script
      else if (is.fun(to)) {
          await to(animate, stop);
        }

      result = {
        value: getValue(),
        finished: true
      };
    } catch (err) {
      if (err !== cancelToken) {
        throw err;
      }

      result = {
        value: getValue(),
        cancelled: true
      };
    } finally {
      state.promise = undefined;

      if (to == state.asyncTo) {
        state.asyncTo = undefined;
      }
    }

    if (props.onRest) {
      props.onRest(result);
    }

    return result;
  })();
} //
// scheduleProps(props, state, action)
//

/**
 * Pass props to your action when any delay is finished and the
 * props weren't cancelled before then.
 */

function scheduleProps(asyncId, props, state, action) {
  return new Promise((resolve, reject) => {
    let delay = props.delay,
        cancel = props.cancel,
        reset = props.reset;

    if (is.num(delay) && delay > 0) {
      setTimeout(run, delay);
    } else run();

    function run() {
      // Might be cancelled during delay.
      if (asyncId <= (state.cancelId || 0)) {
        cancel = true;
      } else {
        cancel = matchProp(cancel, state.key);

        if (cancel) {
          state.cancelId = asyncId;
        }
      }

      reset = !cancel && matchProp(reset, state.key);

      try {
        action(_extends({}, props, {
          asyncId,
          cancel,
          reset
        }), resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}

// The `mass` prop defaults to 1
const config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};

/** The spring cannot be animated */

const DISPOSED = 'DISPOSED';
/** The spring has not animated yet */

const CREATED = 'CREATED';
/** The spring has animated before */

const IDLE = 'IDLE';
/** The spring is frozen in time */

const PAUSED = 'PAUSED';
/** The spring is animating */

const ACTIVE = 'ACTIVE';

const noop = () => {};

const BASE_CONFIG = _extends({}, config.default, {
  mass: 1,
  velocity: 0,
  progress: 0,
  easing: t => t,
  clamp: false
});
/** An opaque animatable value */


class SpringValue extends AnimationValue {
  constructor(key) {
    super(key);
    /** The animation state */

    this.animation = {
      value: this
    };
    /** The lifecycle phase of this spring */

    this._phase = CREATED;
    /** The last time each prop changed */

    this._timestamps = {};
    /** Some props have customizable default values */

    this._defaultProps = {};
    /** Cancel any update from before this timestamp */

    this._lastAsyncId = 0;
    this._state = {
      key
    };
  }

  get idle() {
    return !this.is(ACTIVE);
  }
  /** Check the current phase */


  is(phase) {
    return this._phase == phase;
  }
  /** Set the current value, while stopping the current animation */


  set(value) {
    if (this._set(value) && this.idle) {
      // Since "_stop" calls "_onChange" only when not idle, we need this.
      this._onChange(this.get(), true);
    }

    this._stop();

    return this;
  }
  /**
   * Freeze the active animation in time.
   * This does nothing when not animating.
   *
   * Call `start` to unpause.
   */


  pause() {
    checkDisposed(this, 'pause');

    if (!this.idle) {
      this._phase = PAUSED;
      frameLoop.stop(this);
    }
  }
  /**
   * Skip to the end of the current animation.
   *
   * All `onRest` callbacks are passed `{finished: true}`
   */


  finish(to) {
    if (!this.idle) {
      const anim = this.animation; // Decay animations have an implicit goal.

      if (!anim.config.decay && is.und(to)) {
        to = anim.to;
      } // Set the value if we can.


      if (!is.und(to)) {
        this._set(to);
      } // Exit the frameloop.


      this._stop(true);
    }

    return this;
  }
  /** Push props into the pending queue. */


  update(props) {
    checkDisposed(this, 'update'); // Ensure the initial value can be accessed by animated components.

    this.setNodeWithProps(props);
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }

  async start(to, arg2) {
    checkDisposed(this, 'start'); // Unpause if possible.

    if (this.is(PAUSED)) {
      this._start();

      if (this._state.asyncTo) {
        this._state.unpause();
      }
    }

    let queue;

    if (!is.und(to)) {
      queue = [is.obj(to) ? to : _extends({}, arg2, {
        to
      })];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }

    await Promise.all(queue.map(props => this._animate(props)));
    return {
      finished: true,
      value: this.get(),
      spring: this
    };
  }
  /**
   * Stop the current animation, and cancel any delayed updates.
   */


  stop() {
    if (!this.is(DISPOSED)) {
      this._state.cancelId = this._lastAsyncId;

      this._to(this.get());

      this._stop();
    }

    return this;
  }
  /** Restart the animation. */


  reset() {
    this._animate({
      reset: true
    });
  }
  /** Prevent future animations, and stop the current animation */


  dispose() {
    if (!this.is(DISPOSED)) {
      if (this.animation) {
        // Prevent "onRest" calls when disposed.
        this.animation.onRest = undefined;
      }

      this.stop();
      this._phase = DISPOSED;
    }
  }
  /** Observe value changes. To stop observing, call the returned function. */


  onChange(fn) {
    this._children.add(fn);

    return () => this._children.delete(fn);
  }
  /** @internal */


  onParentChange(value, idle) {
    const anim = this.animation; // The "FrameLoop" handles everything other than immediate animation.

    if (anim.immediate) {
      if (idle) {
        this.finish(value);
      } else {
        this._set(value);
      }
    } // When our parent is not a spring, it won't tell us to enter the frameloop
    // because it never does so itself. Instead, we must react to value changes.
    else if (this.idle) {
        anim.fromValues = anim.values.map(node => node.lastPosition);

        this._start();
      }
  }
  /** @internal Called by the frameloop */


  onFrame(idle, changed) {
    if (idle) {
      this.finish();
    } else if (changed) {
      this._onChange(this.get());
    }
  }
  /**
   * @internal
   * Analyze the given `value` to determine which data type is being animated.
   * Then, create an `Animated` node for that data type and make it our `node`.
   */


  setNodeWithValue(value) {
    if (value != null) {
      this.node = this._getNodeType(value).create(computeGoal(value));
    }
  }
  /**
   * @internal
   * Analyze the given `props` to determine which data type is being animated.
   * Then, create an `Animated` node for that data type and make it our `node`.
   * If we already have a `node`, do nothing but return the `{from, to}` range.
   */


  setNodeWithProps(props) {
    const range = this._getRange(props);

    if (!this.node) {
      this.setNodeWithValue(range.from != null ? range.from : range.to);
    }

    return range;
  }
  /** Return the `Animated` node constructor for a given value */


  _getNodeType(value) {
    const parent = isAnimationValue(value) ? value : null;
    const parentType = parent && parent.node && parent.node.constructor;

    if (!parent && isFluidValue(value)) {
      value = value.get();
    }

    return parentType == AnimatedString ? AnimatedValue : parentType || (is.arr(value) ? AnimatedArray : needsInterpolation(value) ? AnimatedString : AnimatedValue);
  }
  /** Pluck the `to` and `from` props */


  _getRange(props) {
    const to = props.to,
          from = props.from;
    const key = this.key || '';
    return {
      to: !is.obj(to) || isFluidValue(to) ? to : to[key],
      from: !is.obj(from) || isFluidValue(from) ? from : from[key]
    };
  }
  /** Update this value's animation using the given props. */


  _animate(props) {
    // Ensure the initial value can be accessed by animated components.
    const range = this.setNodeWithProps(props);
    const timestamp = now();
    return scheduleProps(++this._lastAsyncId, props, this._state, (props, resolve) => {
      const to = props.to;

      if (is.arr(to) || is.fun(to)) {
        resolve(runAsync(to, props, this._state, () => this.get(), () => this.is(PAUSED), this.start.bind(this), this.stop.bind(this)));
      } else if (props.cancel) {
        this.stop();
        resolve({
          value: this.get(),
          cancelled: true
        });
      } else {
        this._update(range, props, timestamp, resolve);
      }
    });
  }
  /** Update the internal `animation` object */


  _update(_ref, props, timestamp, resolve) {
    let to = _ref.to,
        from = _ref.from;
    const defaultProps = this._defaultProps;
    /** Get the value of a prop, or its default value */

    const get = prop => !is.und(props[prop]) ? props[prop] : defaultProps[prop];

    const onAnimate = get('onAnimate');

    if (onAnimate) {
      onAnimate(props, this);
    } // Cast from a partial type.


    const anim = this.animation;
    const timestamps = this._timestamps;
    /** Return true if our prop can be used. This only affects delayed props. */

    const diff = prop => {
      if (timestamp >= (timestamps[prop] || 0)) {
        timestamps[prop] = timestamp;
        return true;
      }

      return false;
    };

    const prevTo = anim.to,
          prevFrom = anim.from; // The "reverse" prop only affects one update.

    if (props.reverse) {
      var _ref2 = [from, to];
      to = _ref2[0];
      from = _ref2[1];
    }

    if (!is.und(to) && diff('to')) {
      this._to(to);
    } else {
      to = prevTo;
    }

    if (!is.und(from) && diff('from')) {
      anim.from = from;
    } else {
      from = anim.from;
    }

    if (isFluidValue(from)) {
      from = from.get();
    }

    const reset = props.reset && !is.und(from);
    const changed = !is.und(to) && !isEqual(to, prevTo);
    const parent = isFluidValue(to) && to;
    /** The current value */

    let value = reset ? from : this.get();

    if (is.und(from)) {
      from = value;
    }
    /** When true, this spring must be in the frameloop. */


    let started = !!parent || (changed || reset) && !isEqual(value, to);
    /** The initial velocity before this `animate` call. */

    const lastVelocity = anim.config ? anim.config.velocity : 0; // The "config" prop either overwrites or merges into the existing config.

    let config = props.config;

    if (config || started || !anim.config) {
      const key = this.key || '';
      config = _extends({}, callProp(defaultProps.config, key), callProp(config, key));

      if (!started && canMergeConfigs(config, anim.config)) {
        Object.assign(anim.config, config);
      } else {
        anim.config = config = _extends({}, BASE_CONFIG, config);
      } // Derive "tension" and "friction" from "frequency" and "damping".


      if (!is.und(config.frequency)) {
        const damping = is.und(config.damping) ? 1 : config.damping;
        config.tension = Math.pow(config.frequency, 2) * config.mass;
        config.friction = damping * Math.sqrt(config.tension * config.mass) / 0.5;
      } // Cache the angular frequency in rad/ms


      config.w0 = Math.sqrt(config.tension / config.mass) / 1000;
    } else {
      config = anim.config;
    } // Always start animations with velocity.


    if (!started && (config.decay || !is.und(to))) {
      started = !isEqual(config.velocity, lastVelocity);
    } // Reset our internal `Animated` node if starting.


    let node = this.node;
    let nodeType;

    if (changed) {
      nodeType = this._getNodeType(to);

      if (nodeType !== node.constructor) {
        throw Error(`Cannot animate to the given "to" prop, because the current value has a different type`);
      }
    } else {
      nodeType = node.constructor;
    } // The final value of our animation, excluding the "to" value.
    // The "FrameLoop" decides our goal value when "parent" exists.


    let goal = parent ? null : computeGoal(to);

    if (nodeType == AnimatedString) {
      from = 0;
      goal = 1;
    } // Ensure the current value equals the "from" value when reset
    // and when the "from" value is updated before the first animation.


    if (reset || this.is(CREATED) && !is.und(anim.from) && !isEqual(anim.from, prevFrom)) {
      node.setValue(value = from);
    } // Event props are replaced on every update.


    anim.onStart = get('onStart');
    anim.onChange = get('onChange'); // Update the default props.

    if (props.default) {
      each(DEFAULT_PROPS, prop => {
        // Default props can only be null, an object, or a function.
        if (/function|object/.test(typeof props[prop])) {
          defaultProps[prop] = props[prop];
        }
      });
    }

    if (!started) {
      // Resolve the "animate" promise.
      return resolve({
        value,
        spring: this,
        finished: true
      });
    } // This must come *before* "fromValues" is set,
    // because it updates "node.lastPosition"


    this._reset();

    anim.values = node.getPayload();
    anim.toValues = parent ? null : toArray(goal);
    anim.fromValues = anim.values.map(node => node.lastPosition);
    anim.immediate = !(parent || is.num(goal) || is.arr(goal)) || !!matchProp(get('immediate'), this.key);
    const onRestQueue = anim.onRest; // The "onRest" prop is always first in the queue.

    anim.onRest = [get('onRest') || noop, resolve]; // Resolve the promise for unfinished animations.

    if (onRestQueue && onRestQueue.length > 1) {
      const result = {
        value,
        spring: this,
        cancelled: true
      }; // Skip the "onRest" prop, as the animation is still active.

      for (let i = 1; i < onRestQueue.length; i++) {
        onRestQueue[i](result);
      }
    }

    this._start();
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */


  _to(value) {
    const anim = this.animation;

    if (isFluidValue(anim.to)) {
      if (value == anim.to) return;
      anim.to.removeChild(this);
    }

    anim.to = value;

    if (isFluidValue(value)) {
      value.addChild(this);
      this.priority = (value.priority || 0) + 1;
    } else {
      this.priority = 0;
    }
  }
  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */


  _set(value) {
    if (isFluidValue(value)) {
      value = value.get();
    }

    const node = this.node;

    if (node) {
      if (isEqual(value, node.getValue())) {
        return false;
      }

      node.setValue(value);
    } else {
      this.setNodeWithValue(value);
    }

    return true;
  }
  /** Notify change observers */


  _onChange(value, idle) {
    if (idle === void 0) {
      idle = false;
    }

    const anim = this.animation;

    if (!anim.changed && !idle) {
      anim.changed = true; // The "onStart" prop is called on the first change after entering the
      // frameloop, but never for immediate animations.

      if (anim.onStart) {
        anim.onStart(this);
      }
    }

    if (anim.onChange) {
      anim.onChange(value, this);
    }

    super._onChange(value, idle);
  }

  _onPriorityChange(priority) {
    if (!this.idle) {
      // Re-enter the frameloop so our new priority is used.
      frameLoop.stop(this).start(this);
    }

    super._onPriorityChange(priority);
  }
  /** Reset our node, and the nodes of every descendant spring */


  _reset(goal) {
    if (goal === void 0) {
      goal = computeGoal(this.animation.to);
    }

    super._reset(goal);
  }
  /** Enter the frameloop */


  _start() {
    if (this.idle) {
      this._phase = ACTIVE; // Animations without "onRest" cannot enter the frameloop.

      const anim = this.animation;

      if (anim.onRest) {
        anim.changed = false; // The "skipAnimation" global avoids the frameloop.

        if (skipAnimation) {
          this.finish(anim.to);
        } else {
          frameLoop.start(this);
        }
      } // Tell animatable children to enter the frameloop.


      each(this._children, child => {
        if (child instanceof SpringValue) {
          child._start();
        }
      });
    }
  }
  /** Exit the frameloop and notify `onRest` listeners */


  _stop(finished) {
    if (finished === void 0) {
      finished = false;
    }

    if (!this.idle) {
      this._phase = IDLE; // Always let change observers know when a spring becomes idle.

      this._onChange(this.get(), true);

      const anim = this.animation;
      const onRestQueue = anim.onRest; // Animations without "onRest" never enter the frameloop.

      if (onRestQueue) {
        frameLoop.stop(this);
        each(anim.values, node => {
          node.done = true;
        }); // Preserve the "onRest" prop between animations.

        anim.onRest = [onRestQueue[0]]; // Never call the "onRest" prop for immediate or no-op animations.

        if (anim.immediate || !anim.changed) {
          onRestQueue[0] = noop;
        }

        const result = {
          value: this.get(),
          spring: this,
          finished
        };
        each(onRestQueue, onRest => onRest(result));
      }
    }
  }

} // TODO: makes this tree-shakeable

function checkDisposed(spring, name) {
  if (spring.is(DISPOSED)) {
    throw Error(`Cannot call "${name}" of disposed "${spring.constructor.name}" object`);
  }
} // Merge configs when the existence of "decay" or "duration" has not changed.


function canMergeConfigs(src, dest) {
  return !!dest && is.und(src.decay) == is.und(dest.decay) && is.und(src.duration) == is.und(dest.duration);
} // Compute the goal value, converting "red" to "rgba(255, 0, 0, 1)" in the process


function computeGoal(value) {
  return is.arr(value) ? value.map(computeGoal) : isFluidValue(value) ? computeGoal(value.get()) : needsInterpolation(value) ? createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}

let nextId = 1;
let lastAsyncId = 0;
class Controller {
  constructor(props) {
    this.id = nextId++;
    /** The values that changed in the last animation frame */

    this.frame = {};
    /** Fallback values for undefined props */

    this.defaultProps = {};
    /** The queue of pending props */

    this.queue = [];
    /** The current controller-only props (eg: `onFrame` and async state) */

    this._props = {};
    /** The spring values that manage their animations */

    this._springs = {};
    this._onChange = this._onChange.bind(this);
    this._onFrame = this._onFrame.bind(this);

    if (props) {
      props.default = true;
      this.start(props);
    }
  }
  /** Equals true when no springs are animating */


  get idle() {
    return !this._props.promise && Object.values(this._springs).every(s => s.idle);
  }
  /** Get all existing `SpringValue` objects. This clones the internal store. */


  get springs() {
    return _extends({}, this._springs);
  }

  get(key) {
    return this._springs[key];
  }
  /** Push an update onto the queue of each value. */


  update(props) {
    if (props) this.queue.push(this._update(props));
    return this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */


  async start(queue) {
    if (queue) {
      queue = toArray(queue).map(props => this._update(props));
    } else {
      queue = this.queue;
      this.queue = [];
    }

    const promises = [];
    each(queue, props => {
      const to = props.to,
            onFrame = props.onFrame,
            keys = props.keys;
      const asyncTo = (is.arr(to) || is.fun(to)) && to;

      if (asyncTo) {
        props.to = undefined;
      }

      promises.push( // Send updates to every affected key.
      ...keys.map(key => this._springs[key].start(props)), // Schedule controller-only props.
      scheduleProps(++lastAsyncId, props, this._props, (props, resolve) => {
        if (!props.cancel) {
          // Never reuse "onFrame" from a previous update.
          this._props.onFrame = onFrame || this.defaultProps.onFrame;

          if (onFrame && props.default) {
            this.defaultProps.onFrame = onFrame;
          }
        } // Start, replace, or cancel the async animation.


        if (asyncTo) {
          resolve(runAsync(asyncTo, props, this._props, this._get.bind(this), () => false, // TODO: add pausing to Controller
          this.start.bind(this), this.stop.bind(this)));
        } else {
          resolve({
            value: 0,
            finished: !props.cancel
          });
        }
      }));
    });
    const results = await Promise.all(promises);
    return {
      value: this._get(),
      finished: results.every(result => result.finished)
    };
  }
  /** Stop one animation, some animations, or all animations */


  stop(keys) {
    if (is.und(keys)) {
      each(this._springs, spring => spring.stop());
    } else {
      each(toArray(keys), key => this._springs[key].stop());
    }

    return this;
  }
  /** Restart every animation. */


  reset() {
    each(this._springs, spring => spring.reset()); // TODO: restart async "to" prop

    return this;
  }
  /** Destroy every spring in this controller */


  dispose() {
    this._props.asyncTo = undefined;
    each(this._springs, spring => spring.dispose());
    this._springs = {};
  }
  /** Get the current value of every spring */


  _get() {
    const values = {};
    each(this._springs, (spring, key) => {
      values[key] = spring.get();
    });
    return values;
  }
  /** Create a spring for every given key, and ensure they have `Animated` nodes. */


  _setSprings(keys, from, to) {
    each(keys, key => {
      if (!this._springs[key]) {
        const spring = this._springs[key] = new SpringValue(key);
        spring.addChild(this._onChange);
        spring.setNodeWithProps({
          from,
          to
        });
      }
    });
  }
  /** Prepare an update with the given props. */


  _update(propsArg) {
    const props = interpolateTo(propsArg);
    const keys = props.keys = extractKeys(props, this._springs);
    let from = props.from,
        to = props.to; // Avoid sending async "to" prop to springs.

    if (is.arr(to) || is.fun(to)) {
      to = undefined;
    } // Create our springs and give them values.


    if (from || to) {
      this._setSprings(keys, from, to);
    }

    return props;
  }
  /** @internal Attached as an observer to every spring */


  _onChange(value, spring) {
    if (this._props.onFrame) {
      this.frame[spring.key] = value;
      frameLoop.onFrame(this._onFrame);
    }
  }
  /** @internal Called at the end of every animation frame */


  _onFrame() {
    if (Object.keys(this.frame).length) {
      this._props.onFrame(this.frame);

      this.frame = {};
    }
  }

}
/** Determine which keys should receive an update */

function extractKeys(props, springs) {
  const keys = new Set();
  /** Collect keys with a defined value */

  const getDefinedKeys = obj => each(obj, (value, key) => {
    if (!is.und(value)) {
      keys.add(key);
    }
  });

  const from = props.from,
        to = props.to;
  if (is.obj(to)) getDefinedKeys(to);
  if (from) getDefinedKeys(from); // When neither "from" or "to" have a key with a defined value,
  // return the keys for every existing spring.

  return keys.size ? Array.from(keys) : Object.keys(springs);
}

/** @internal */

function useSprings(length, props, deps) {
  const propsFn = is.fun(props) && props;

  if (propsFn && arguments.length < 3) {
    deps = []; // Skip updates after first render.
  } // The "ref" prop is taken from the props of the first spring only.
  // The ref is assumed to *never* change after the first render.


  let ref;
  const ctrls = useMemo(() => [], []);
  const updates = [];
  const prevLength = usePrev(length) || 0;
  useMemo(() => {
    if (prevLength > length) {
      for (let i = length; i < prevLength; i++) {
        ctrls[i].dispose();
      }
    }

    ctrls.length = length;

    for (let i = 0; i < length; i++) {
      const ctrl = ctrls[i] || (ctrls[i] = new Controller());
      const update = propsFn ? propsFn(i, ctrl) : props[i];

      if (update) {
        update.default = true;

        if (i == 0 && update.ref) {
          ref = update.ref;
        }

        if (i < prevLength) {
          updates[i] = update;
        } else {
          // Update new controllers immediately, so their
          // spring values exist during first render.
          ctrl.update(update);
        }
      }
    }
  }, deps);
  const api = useMemo$1(() => ({
    get controllers() {
      return ctrls;
    },

    update: props => {
      each(ctrls, (ctrl, i) => {
        ctrl.update(getProps(props, i, ctrl));
        if (!ref) ctrl.start();
      });
      return api;
    },

    async start() {
      const results = await Promise.all(ctrls.map(ctrl => ctrl.start()));
      return {
        value: results.map(result => result.value),
        finished: results.every(result => result.finished)
      };
    },

    stop: keys => each(ctrls, ctrl => ctrl.stop(keys))
  }), []);
  useImperativeHandle(ref, () => api);
  useIsomorphicLayoutEffect(() => {
    each(updates, (update, i) => ctrls[i].update(update));

    if (!ref) {
      each(ctrls, ctrl => ctrl.start());
    }
  }, deps);
  useOnce(() => () => {
    each(ctrls, ctrl => ctrl.dispose());
  });
  const values = ctrls.map(ctrl => ctrl.springs);
  return propsFn || arguments.length == 3 ? [values, api.update, api.stop] : values;
}

/** @internal */

function useSpring(props, deps) {
  const isFn = is.fun(props);

  const _useSprings = useSprings(1, isFn ? props : [props], deps),
        _useSprings$ = _useSprings[0],
        values = _useSprings$[0],
        update = _useSprings[1],
        stop = _useSprings[2];

  return isFn || arguments.length == 3 ? [values, update, stop] : values;
}

function useTrail(length, propsArg, deps) {
  const propsFn = is.fun(propsArg) && propsArg;

  if (propsFn && arguments.length < 3) {
    deps = []; // Skip updates after first render.
  }

  const ctrls = [];
  const result = useSprings(length, (i, ctrl) => {
    ctrls[i] = ctrl;
    return getProps(propsArg, i, ctrl);
  }, deps);
  useIsomorphicLayoutEffect(() => {
    const reverse = is.obj(propsArg) && propsArg.reverse;

    for (let i = 0; i < ctrls.length; i++) {
      const parent = ctrls[i + (reverse ? 1 : -1)];
      if (parent) ctrls[i].update({
        to: parent.springs
      }).start();
    }
  }, deps);
  const update = result[1];

  result[1] = propsArg => {
    const reverse = is.obj(propsArg) && propsArg.reverse;
    return update((i, ctrl) => {
      const props = getProps(propsArg, i, ctrl);
      const parent = ctrls[i + (reverse ? 1 : -1)];
      if (parent) props.to = parent.springs;
      return props;
    });
  };

  return propsFn ? result : result[0];
}

/** This transition is being mounted */

const MOUNT = 0;
/** This transition is entering or has entered */

const ENTER = 1;
/** This transition had its animations updated */

const UPDATE = 2;
/** This transition will expire after animating */

const LEAVE = 3;

function getKeys(items, _ref) {
  let key = _ref.key,
      _ref$keys = _ref.keys,
      keys = _ref$keys === void 0 ? key : _ref$keys;
  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);
}

function useTransition(data, props, deps) {
  const ref = props.ref,
        reset = props.reset,
        sort = props.sort,
        _props$trail = props.trail,
        trail = _props$trail === void 0 ? 0 : _props$trail,
        _props$expires = props.expires,
        expires = _props$expires === void 0 ? Infinity : _props$expires; // Every item has its own transition.

  const items = toArray(data);
  const transitions = []; // Keys help with reusing transitions between renders.
  // The `key` prop can be undefined (which means the items themselves are used
  // as keys), or a function (which maps each item to its key), or an array of
  // keys (which are assigned to each item by index).

  const keys = getKeys(items, props); // The "onRest" callbacks need a ref to the latest transitions.

  const usedTransitions = useRef(null);
  const prevTransitions = usedTransitions.current;
  useIsomorphicLayoutEffect(() => {
    usedTransitions.current = transitions;
  }); // Destroy all transitions on dismount.

  useOnce(() => () => each(usedTransitions.current, t => {
    if (t.expiresBy != null) {
      clearTimeout(t.expirationId);
    }

    t.ctrl.dispose();
  })); // Map old indices to new indices.

  const reused = [];
  if (prevTransitions && !reset) each(prevTransitions, (t, i) => {
    // Expired transitions are not rendered.
    if (t.expiresBy != null) {
      clearTimeout(t.expirationId);
    } else {
      i = reused[i] = keys.indexOf(t.key);
      if (~i) transitions[i] = t;
    }
  }); // Mount new items with fresh transitions.

  each(items, (item, i) => {
    transitions[i] || (transitions[i] = {
      key: keys[i],
      item,
      phase: MOUNT,
      ctrl: new Controller()
    });
  }); // Update the item of any transition whose key still exists,
  // and ensure leaving transitions are rendered until they finish.

  if (reused.length) {
    let i = -1;
    each(reused, (keyIndex, prevIndex) => {
      const t = prevTransitions[prevIndex];

      if (~keyIndex) {
        i = transitions.indexOf(t);
        transitions[i] = _extends({}, t, {
          item: items[keyIndex]
        });
      } else if (props.leave) {
        transitions.splice(++i, 0, t);
      }
    });
  }

  if (is.fun(sort)) {
    transitions.sort((a, b) => sort(a.item, b.item));
  } // Track cumulative delay for the "trail" prop.


  let delay = -trail; // Expired transitions use this to dismount.

  const forceUpdate = useForceUpdate();
  const defaultProps = {};
  each(DEFAULT_PROPS, prop => {
    if (/function|object/.test(typeof props[prop])) {
      defaultProps[prop] = props[prop];
    }
  }); // Generate changes to apply in useEffect.

  const changes = new Map();
  each(transitions, (t, i) => {
    let to;
    let from;
    let phase;

    if (t.phase == MOUNT) {
      to = props.enter;
      phase = ENTER; // The "initial" prop is only used on first render. It always overrides
      // the "from" prop when defined, and it makes "enter" instant when null.

      from = props.initial;

      if (is.und(from) || prevTransitions && !reset) {
        from = props.from;
      }
    } else {
      const isLeave = keys.indexOf(t.key) < 0;

      if (t.phase < LEAVE) {
        if (isLeave) {
          to = props.leave;
          phase = LEAVE;
        } else if (to = props.update) {
          phase = UPDATE;
        } else return;
      } else if (!isLeave) {
        to = props.enter;
        phase = ENTER;
      } else return;
    } // The payload is used to update the spring props once the current render is committed.


    const payload = _extends({}, defaultProps, {
      // When "to" is a function, it can return (1) an array of "useSpring" props,
      // (2) an async function, or (3) an object with any "useSpring" props.
      to: to = callProp(to, t.item, i),
      from: callProp(from, t.item, i),
      delay: delay += trail,
      config: callProp(props.config || defaultProps.config, t.item, i)
    }, is.obj(to) && interpolateTo(to));

    const onRest = payload.onRest;

    payload.onRest = result => {
      if (is.fun(onRest)) {
        onRest(result);
      }

      if (t.phase == LEAVE && t.ctrl.idle) {
        t.expiresBy = now() + expires;

        if (expires <= 0) {
          forceUpdate();
        } else {
          // Postpone dismounts while other controllers are active.
          const transitions = usedTransitions.current;

          if (transitions.every(t => t.ctrl.idle)) {
            forceUpdate();
          } // When `expires` is infinite, postpone dismount until next render.
          else if (expires < Infinity) {
              t.expirationId = setTimeout(forceUpdate, expires);
            }
        }
      }
    };

    const change = {
      phase
    };
    changes.set(t, change); // To ensure all Animated nodes exist during render,
    // the payload must be applied immediately for new items.

    if (t.phase > MOUNT) {
      change.payload = payload;
    } else {
      t.ctrl.update(payload);
    }
  });
  const api = useMemo$1(() => ({
    get controllers() {
      return usedTransitions.current.map(t => t.ctrl);
    },

    update(props) {
      each(usedTransitions.current, (t, i) => t.ctrl.update(is.fun(props) ? props(i, t.ctrl) : is.arr(props) ? props[i] : props));
      return api;
    },

    async start() {
      const transitions = usedTransitions.current;
      const results = await Promise.all(transitions.map(t => t.ctrl.start()));
      return {
        value: results.map(result => result.value),
        finished: results.every(result => result.finished)
      };
    },

    stop: keys => each(usedTransitions.current, t => t.ctrl.stop(keys))
  }), []);
  useImperativeHandle(ref, () => api);
  useIsomorphicLayoutEffect(() => {
    each(changes, (_ref2, t) => {
      let phase = _ref2.phase,
          payload = _ref2.payload;
      t.phase = phase;
      if (payload) t.ctrl.update(payload);
      if (!ref) t.ctrl.start();
    });
  }, reset ? void 0 : deps);
  return render => transitions.map(t => {
    const elem = render(t.ctrl.springs, t.item, t);
    return elem && elem.type ? React.createElement(elem.type, Object.assign({}, elem.props, {
      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,
      ref: elem.ref
    })) : elem;
  });
}

function Spring(_ref) {
  let children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  return children(useSpring(props));
}
function Trail(_ref2) {
  let items = _ref2.items,
      children = _ref2.children,
      props = _objectWithoutPropertiesLoose(_ref2, ["items", "children"]);

  const trails = useTrail(items.length, props);
  return items.map((item, index) => {
    const result = children(item, index);
    return is.fun(result) ? result(trails[index]) : result;
  });
}
function Transition(_ref3) {
  let items = _ref3.items,
      children = _ref3.children,
      props = _objectWithoutPropertiesLoose(_ref3, ["items", "children"]);

  return useTransition(items, props)(children);
}

/** Map the value of one or more dependencies */

const to = function to(source) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return new Into(source, args);
};
/** @deprecated Use the `to` export instead */

const interpolate = function interpolate(source) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return deprecateInterpolate(), new Into(source, args);
};

class FrameLoop {
  constructor(_temp) {
    let _ref = _temp === void 0 ? {} : _temp,
        update = _ref.update,
        requestFrame = _ref.requestFrame;

    /**
     * The animated springs
     */
    this.springs = [];
    /**
     * True when at least one spring is animating.
     */

    this.active = false;
    /** Equals true when a frame is being processed. */

    this.updating = false;
    /** Equals true when writing to native attributes. */

    this.writing = false; // These queues are swapped at the end of every frame,
    // after the current queue is drained.

    this._queues = [new Set(), new Set()];
    /** `onWrite` callbacks are flushed on every frame, after `onFrame` callbacks are flushed. */

    this._writes = new Set();

    this._requestFrame = // The global `requestAnimationFrame` must be dereferenced to avoid "Illegal invocation" errors
    requestFrame || (fn => (0, requestAnimationFrame)(fn));

    this.update = update && update.bind(this) || (time => {
      if (!this.active) {
        return false;
      }

      if (is.und(time)) {
        time = performanceNow();
      }

      let dt = time - this.lastTime;

      if (dt > 0) {
        // http://gafferongames.com/game-physics/fix-your-timestep/
        if (dt > 64) dt = 64;
        this.updating = true;
        const springs = this.springs;
        if (springs.length) [...springs].forEach(spring => {
          spring.idle || this.advance(dt, spring);
        }); // Notify frame listeners.

        const queues = this._queues;
        const queue = queues[0];

        if (queue.size) {
          // Run and clear the queue.
          queue.forEach(onFrame => onFrame());
          queue.clear(); // Swap the queues.

          queues[0] = queues[1];
          queues[1] = queue;
        }

        const writes = this._writes;

        if (writes.size) {
          this.writing = true;
          writes.forEach(write => write(time));
          this.writing = false;
          writes.clear();
        }

        this.updating = false;

        if (!this.springs.length) {
          return this.active = false;
        }
      }

      this.lastTime = time;

      this._requestFrame(this.update);

      return true;
    });
  }
  /**
   * Schedule a function to run at the end of the current frame,
   * after all springs have been updated.
   *
   * Pass `true` as the 2nd argument to run at the end of the **next** frame.
   */


  onFrame(cb, next) {
    this._queues[next && this.updating ? 1 : 0].add(cb);

    this._start();
  }
  /**
   * Schedule a function run at the end of the current frame,
   * after all `onFrame` callbacks have been called.
   *
   * Calling `onWrite` from inside an `onWrite` callback simply
   * calls the nested write immediately.
   */


  onWrite(cb) {
    if (this.writing) {
      cb(this.lastTime);
    } else {
      this._writes.add(cb);
    }
  }
  /**
   * Start animating the given spring.
   *
   * Beware: Never `start` the same spring twice (without `stop` between).
   */


  start(spring) {
    const springs = this.springs;
    let i = springs.findIndex(s => s.priority > spring.priority);
    if (i < 0) i = springs.length;
    springs.splice(i, 0, spring);

    this._start();
  }

  _start() {
    if (!this.active) {
      this.active = true;
      this.lastTime = performanceNow();

      this._requestFrame(this.update);
    }
  }
  /**
   * Stop animating the given spring
   */


  stop(spring) {
    const springs = this.springs;
    const i = springs.indexOf(spring);
    if (~i) springs.splice(i, 1);
    return this;
  }
  /**
   * Advance an animation forward one frame.
   */


  advance(dt, spring) {
    let idle = true;
    let changed = false;
    const anim = spring.animation;
    const parent = isFluidValue(anim.to) && anim.to;
    const payload = isAnimationValue(parent) && parent.node.getPayload();
    anim.values.forEach((node, i) => {
      if (node.done) return;
      let to = payload ? payload[i].lastPosition : parent ? toArray(parent.get())[i] : anim.toValues[i]; // Parent springs must finish before their children can.

      const canFinish = !payload || payload[i].done; // Jump to end value for immediate animations.

      if (anim.immediate) {
        node.done = canFinish;

        if (node.setValue(to)) {
          changed = true;
        }

        return;
      }

      const config = anim.config; // Loose springs never move.

      if (config.tension == 0) {
        node.done = true;
        return;
      }

      const elapsed = node.elapsedTime += dt;
      const from = anim.fromValues[i];
      const v0 = node.v0 != null ? node.v0 : node.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;
      let position = node.lastPosition;
      let velocity;
      let finished; // Duration easing

      if (!is.und(config.duration)) {
        let p = config.progress;
        if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);
        position = from + config.easing(p) * (to - from);
        velocity = (position - node.lastPosition) / dt;
        finished = p == 1;
      } // Decay easing
      else if (config.decay) {
          const decay = config.decay === true ? 0.998 : config.decay;
          const e = Math.exp(-(1 - decay) * elapsed);
          position = from + v0 / (1 - decay) * (1 - e); // derivative of position

          velocity = v0 * e;
          finished = Math.abs(node.lastPosition - position) < 0.1;
          if (finished) to = position;
        } // Spring easing
        else {
            velocity = node.lastVelocity == null ? v0 : node.lastVelocity;
            /** The smallest distance from a value before being treated like said value. */

            const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));
            /** The velocity at which movement is essentially none */

            const restVelocity = config.restVelocity || precision; // Bouncing is opt-in (not to be confused with overshooting)

            const bounceFactor = config.clamp ? 0 : config.bounce;
            const canBounce = !is.und(bounceFactor);
            /** When `true`, the value is increasing over time */

            const isGrowing = from == to ? node.v0 > 0 : from < to;
            /** When `true`, the velocity is considered moving */

            let isMoving;
            /** When `true`, the velocity is being deflected or clamped */

            let isBouncing = false;
            const step = 0.05 / config.w0;
            const numSteps = Math.ceil(dt / step);

            for (let n = 0; n < numSteps; ++n) {
              isMoving = Math.abs(velocity) > restVelocity;

              if (!isMoving) {
                finished = Math.abs(to - position) <= precision;

                if (finished) {
                  break;
                }
              }

              if (canBounce) {
                isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.

                if (isBouncing) {
                  velocity = -velocity * bounceFactor;
                  position = to;
                }
              }

              const springForce = -config.tension * 0.000001 * (position - to);
              const dampingForce = -config.friction * 0.001 * velocity;
              const acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2

              velocity = velocity + acceleration * step; // pt/ms

              position = position + velocity * step;
            }
          }

      if (Number.isNaN(position)) {
        throw Error(`Found NaN value while advancing "${spring.key}" animation`);
      }

      if (finished && canFinish) {
        node.done = true;
      } else {
        idle = false;
      }

      node.lastVelocity = velocity;

      if (node.setValue(position, config.round)) {
        changed = true;
      }
    });
    spring.onFrame(idle, changed);
  }

}

Globals.assign({
  frameLoop: new FrameLoop(),
  createStringInterpolator: createStringInterpolator$1,
  applyAnimatedValues: () => false
});
/** Advance all animations forward one frame */

const update = () => Globals.frameLoop.update();

export { Controller, FrameLoop, Spring, SpringValue, Trail, Transition, config, interpolate, to, update, useChain, useSpring, useSprings, useTrail, useTransition };
//# sourceMappingURL=index.js.map
