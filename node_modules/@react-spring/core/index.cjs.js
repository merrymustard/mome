'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var shared = require('@react-spring/shared');
var _regeneratorRuntime = _interopDefault(require('@babel/runtime/regenerator'));
var _asyncToGenerator = _interopDefault(require('@babel/runtime/helpers/asyncToGenerator'));
var React = require('react');
var React__default = _interopDefault(React);
var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _createClass = _interopDefault(require('@babel/runtime/helpers/createClass'));
var G = require('@react-spring/shared/globals');
var useMemoOne = require('use-memo-one');
var _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var animated = require('@react-spring/animated/index.cjs.js');
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
var deprecations = require('@react-spring/shared/deprecations');
var stringInterpolation = require('@react-spring/shared/stringInterpolation');

/** API
 *  useChain(references, timeSteps, timeFrame)
 */

function useChain(refs, timeSteps, timeFrame) {
  if (timeFrame === void 0) {
    timeFrame = 1000;
  }

  shared.useIsomorphicLayoutEffect(function () {
    if (timeSteps) {
      var prevDelay = 0;
      shared.each(refs, function (ref, i) {
        if (!ref.current) return;
        var controllers = ref.current.controllers;

        if (controllers.length) {
          var delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.

          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;
          shared.each(controllers, function (ctrl) {
            shared.each(ctrl.queue, function (props) {
              props.delay = delay + (props.delay || 0);
            });
            ctrl.start();
          });
        }
      });
    } else {
      var p = Promise.resolve();
      shared.each(refs, function (ref) {
        var _ref = ref.current || {},
            controllers = _ref.controllers,
            start = _ref.start;

        if (controllers && controllers.length) {
          // Take the queue of each controller
          var updates = controllers.map(function (ctrl) {
            var q = ctrl.queue;
            ctrl.queue = [];
            return q;
          }); // Apply the queue when the previous ref stops animating

          p = p.then(function () {
            shared.each(controllers, function (ctrl, i) {
              var _ctrl$queue;

              return (_ctrl$queue = ctrl.queue).push.apply(_ctrl$queue, updates[i]);
            });
            return start();
          });
        }
      });
    }
  });
}

var useMemo = function useMemo(create, deps) {
  return useMemoOne.useMemoOne(create, deps || [{}]);
};
function callProp(value) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return shared.is.fun(value) ? value.apply(void 0, args) : value;
}
/** Try to coerce the given value into a boolean using the given key */

var matchProp = function matchProp(value, key) {
  return value === true || !!(key && value && (shared.is.fun(value) ? value(key) : shared.toArray(value).includes(key)));
};
var getProps = function getProps(props, i, arg) {
  return shared.is.fun(props) ? props(i, arg) : shared.is.arr(props) ? props[i] : _extends({}, props);
};
/** These props can have default values */

var DEFAULT_PROPS = ['config', 'immediate', 'onAnimate', 'onStart', 'onChange', 'onRest'];
var RESERVED_PROPS = {
  children: 1,
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  reset: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  lazy: 1,
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  leave: 1,
  update: 1,
  onAnimate: 1,
  onStart: 1,
  onRest: 1,
  onChange: 1,
  onFrame: 1
};
/**
 * Extract any properties whose keys are *not* reserved for customizing your
 * animations. All hooks use this function, which means `useTransition` props
 * are reserved for `useSpring` calls, etc.
 */

function getForwardProps(props) {
  var forward = {};
  shared.each(props, function (value, prop) {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
    }
  });
  return forward;
}

function interpolateTo(props) {
  var to = getForwardProps(props);
  var out = {
    to: to
  };
  shared.each(props, function (val, key) {
    return key in to || (out[key] = val);
  });
  return out;
}

/**
 * Start an async chain or an async script.
 *
 * You should always wrap `runAsync` calls with `scheduleProps` so that
 * you have access to `RunAsyncProps` instead of the usual `SpringProps`.
 *
 * The `T` parameter can be a set of animated values (as an object type)
 * or a primitive type for a single animated value.
 */

function runAsync(_x, _x2, _x3, _x4, _x5, _x6, _x7) {
  return _runAsync.apply(this, arguments);
} //
// scheduleProps(props, state, action)
//

/**
 * Pass props to your action when any delay is finished and the
 * props weren't cancelled before then.
 */

function _runAsync() {
  _runAsync = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee3(to, props, state, getValue, getPaused, update, stop) {
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!props.cancel) {
              _context3.next = 5;
              break;
            }

            state.asyncTo = undefined;
            return _context3.abrupt("return", {
              value: getValue(),
              cancelled: true
            });

          case 5:
            if (!props.reset) {
              _context3.next = 10;
              break;
            }

            _context3.next = 8;
            return state.promise;

          case 8:
            _context3.next = 12;
            break;

          case 10:
            if (!(to === state.asyncTo)) {
              _context3.next = 12;
              break;
            }

            return _context3.abrupt("return", state.promise);

          case 12:
            state.asyncTo = to;
            return _context3.abrupt("return", state.promise = _asyncToGenerator(
            /*#__PURE__*/
            _regeneratorRuntime.mark(function _callee2() {
              var asyncId, cancelToken, isCancelled, defaultProps, animate, result, _iterator, _isArray, _i, _ref3, _props;

              return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      asyncId = props.asyncId;
                      cancelToken = Symbol.for('cancel');

                      isCancelled = function isCancelled() {
                        return to !== state.asyncTo || asyncId <= (state.cancelId || 0);
                      };

                      defaultProps = {};
                      shared.each(DEFAULT_PROPS, function (prop) {
                        if (prop == 'onRest') return;

                        if (/function|object/.test(typeof props[prop])) {
                          defaultProps[prop] = props[prop];
                        }
                      });

                      animate = function animate(arg1, arg2) {
                        if (isCancelled()) {
                          throw cancelToken;
                        }

                        var props = shared.is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {
                          to: arg1
                        });
                        shared.each(defaultProps, function (value, prop) {
                          if (shared.is.und(props[prop])) {
                            props[prop] = value;
                          }
                        });
                        var parentTo = state.asyncTo;
                        return update(props).then(
                        /*#__PURE__*/
                        function () {
                          var _ref2 = _asyncToGenerator(
                          /*#__PURE__*/
                          _regeneratorRuntime.mark(function _callee(result) {
                            return _regeneratorRuntime.wrap(function _callee$(_context) {
                              while (1) {
                                switch (_context.prev = _context.next) {
                                  case 0:
                                    if (state.asyncTo == null) {
                                      state.asyncTo = parentTo;
                                    }

                                    if (!isCancelled()) {
                                      _context.next = 3;
                                      break;
                                    }

                                    throw cancelToken;

                                  case 3:
                                    if (!getPaused()) {
                                      _context.next = 7;
                                      break;
                                    }

                                    _context.next = 6;
                                    return new Promise(function (resolve) {
                                      state.unpause = resolve;
                                    });

                                  case 6:
                                    state.unpause = undefined;

                                  case 7:
                                    return _context.abrupt("return", result);

                                  case 8:
                                  case "end":
                                    return _context.stop();
                                }
                              }
                            }, _callee);
                          }));

                          return function (_x8) {
                            return _ref2.apply(this, arguments);
                          };
                        }());
                      };

                      _context2.prev = 6;

                      if (!shared.is.arr(to)) {
                        _context2.next = 26;
                        break;
                      }

                      _iterator = to, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();

                    case 9:
                      if (!_isArray) {
                        _context2.next = 15;
                        break;
                      }

                      if (!(_i >= _iterator.length)) {
                        _context2.next = 12;
                        break;
                      }

                      return _context2.abrupt("break", 24);

                    case 12:
                      _ref3 = _iterator[_i++];
                      _context2.next = 19;
                      break;

                    case 15:
                      _i = _iterator.next();

                      if (!_i.done) {
                        _context2.next = 18;
                        break;
                      }

                      return _context2.abrupt("break", 24);

                    case 18:
                      _ref3 = _i.value;

                    case 19:
                      _props = _ref3;
                      _context2.next = 22;
                      return animate(_props);

                    case 22:
                      _context2.next = 9;
                      break;

                    case 24:
                      _context2.next = 29;
                      break;

                    case 26:
                      if (!shared.is.fun(to)) {
                        _context2.next = 29;
                        break;
                      }

                      _context2.next = 29;
                      return to(animate, stop);

                    case 29:
                      result = {
                        value: getValue(),
                        finished: true
                      };
                      _context2.next = 37;
                      break;

                    case 32:
                      _context2.prev = 32;
                      _context2.t0 = _context2["catch"](6);

                      if (!(_context2.t0 !== cancelToken)) {
                        _context2.next = 36;
                        break;
                      }

                      throw _context2.t0;

                    case 36:
                      result = {
                        value: getValue(),
                        cancelled: true
                      };

                    case 37:
                      _context2.prev = 37;
                      state.promise = undefined;

                      if (to == state.asyncTo) {
                        state.asyncTo = undefined;
                      }

                      return _context2.finish(37);

                    case 41:
                      if (props.onRest) {
                        props.onRest(result);
                      }

                      return _context2.abrupt("return", result);

                    case 43:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, null, [[6, 32, 37, 41]]);
            }))());

          case 14:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _runAsync.apply(this, arguments);
}

function scheduleProps(asyncId, props, state, action) {
  return new Promise(function (resolve, reject) {
    var delay = props.delay,
        cancel = props.cancel,
        reset = props.reset;

    if (shared.is.num(delay) && delay > 0) {
      setTimeout(run, delay);
    } else run();

    function run() {
      // Might be cancelled during delay.
      if (asyncId <= (state.cancelId || 0)) {
        cancel = true;
      } else {
        cancel = matchProp(cancel, state.key);

        if (cancel) {
          state.cancelId = asyncId;
        }
      }

      reset = !cancel && matchProp(reset, state.key);

      try {
        action(_extends({}, props, {
          asyncId: asyncId,
          cancel: cancel,
          reset: reset
        }), resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}

// The `mass` prop defaults to 1
var config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};

/** The spring cannot be animated */

var DISPOSED = 'DISPOSED';
/** The spring has not animated yet */

var CREATED = 'CREATED';
/** The spring has animated before */

var IDLE = 'IDLE';
/** The spring is frozen in time */

var PAUSED = 'PAUSED';
/** The spring is animating */

var ACTIVE = 'ACTIVE';

var noop = function noop() {};

var BASE_CONFIG = _extends({}, config.default, {
  mass: 1,
  velocity: 0,
  progress: 0,
  easing: function easing(t) {
    return t;
  },
  clamp: false
});
/** An opaque animatable value */


var SpringValue =
/*#__PURE__*/
function (_AnimationValue) {
  _inheritsLoose(SpringValue, _AnimationValue);

  function SpringValue(key) {
    var _this;

    _this = _AnimationValue.call(this, key) || this;
    /** The animation state */

    _this.animation = {
      value: _assertThisInitialized(_this)
    };
    /** The lifecycle phase of this spring */

    _this._phase = CREATED;
    /** The last time each prop changed */

    _this._timestamps = {};
    /** Some props have customizable default values */

    _this._defaultProps = {};
    /** Cancel any update from before this timestamp */

    _this._lastAsyncId = 0;
    _this._state = {
      key: key
    };
    return _this;
  }

  var _proto = SpringValue.prototype;

  /** Check the current phase */
  _proto.is = function is(phase) {
    return this._phase == phase;
  }
  /** Set the current value, while stopping the current animation */
  ;

  _proto.set = function set(value) {
    if (this._set(value) && this.idle) {
      // Since "_stop" calls "_onChange" only when not idle, we need this.
      this._onChange(this.get(), true);
    }

    this._stop();

    return this;
  }
  /**
   * Freeze the active animation in time.
   * This does nothing when not animating.
   *
   * Call `start` to unpause.
   */
  ;

  _proto.pause = function pause() {
    checkDisposed(this, 'pause');

    if (!this.idle) {
      this._phase = PAUSED;
      G.frameLoop.stop(this);
    }
  }
  /**
   * Skip to the end of the current animation.
   *
   * All `onRest` callbacks are passed `{finished: true}`
   */
  ;

  _proto.finish = function finish(to) {
    if (!this.idle) {
      var anim = this.animation; // Decay animations have an implicit goal.

      if (!anim.config.decay && shared.is.und(to)) {
        to = anim.to;
      } // Set the value if we can.


      if (!shared.is.und(to)) {
        this._set(to);
      } // Exit the frameloop.


      this._stop(true);
    }

    return this;
  }
  /** Push props into the pending queue. */
  ;

  _proto.update = function update(props) {
    checkDisposed(this, 'update'); // Ensure the initial value can be accessed by animated components.

    this.setNodeWithProps(props);
    var queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  };

  _proto.start =
  /*#__PURE__*/
  function () {
    var _start2 = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee(to, arg2) {
      var _this2 = this;

      var queue;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              checkDisposed(this, 'start'); // Unpause if possible.

              if (this.is(PAUSED)) {
                this._start();

                if (this._state.asyncTo) {
                  this._state.unpause();
                }
              }

              if (!shared.is.und(to)) {
                queue = [shared.is.obj(to) ? to : _extends({}, arg2, {
                  to: to
                })];
              } else {
                queue = this.queue || [];
                this.queue = [];
              }

              _context.next = 5;
              return Promise.all(queue.map(function (props) {
                return _this2._animate(props);
              }));

            case 5:
              return _context.abrupt("return", {
                finished: true,
                value: this.get(),
                spring: this
              });

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function start(_x, _x2) {
      return _start2.apply(this, arguments);
    }

    return start;
  }()
  /**
   * Stop the current animation, and cancel any delayed updates.
   */
  ;

  _proto.stop = function stop() {
    if (!this.is(DISPOSED)) {
      this._state.cancelId = this._lastAsyncId;

      this._to(this.get());

      this._stop();
    }

    return this;
  }
  /** Restart the animation. */
  ;

  _proto.reset = function reset() {
    this._animate({
      reset: true
    });
  }
  /** Prevent future animations, and stop the current animation */
  ;

  _proto.dispose = function dispose() {
    if (!this.is(DISPOSED)) {
      if (this.animation) {
        // Prevent "onRest" calls when disposed.
        this.animation.onRest = undefined;
      }

      this.stop();
      this._phase = DISPOSED;
    }
  }
  /** Observe value changes. To stop observing, call the returned function. */
  ;

  _proto.onChange = function onChange(fn) {
    var _this3 = this;

    this._children.add(fn);

    return function () {
      return _this3._children.delete(fn);
    };
  }
  /** @internal */
  ;

  _proto.onParentChange = function onParentChange(value, idle) {
    var anim = this.animation; // The "FrameLoop" handles everything other than immediate animation.

    if (anim.immediate) {
      if (idle) {
        this.finish(value);
      } else {
        this._set(value);
      }
    } // When our parent is not a spring, it won't tell us to enter the frameloop
    // because it never does so itself. Instead, we must react to value changes.
    else if (this.idle) {
        anim.fromValues = anim.values.map(function (node) {
          return node.lastPosition;
        });

        this._start();
      }
  }
  /** @internal Called by the frameloop */
  ;

  _proto.onFrame = function onFrame(idle, changed) {
    if (idle) {
      this.finish();
    } else if (changed) {
      this._onChange(this.get());
    }
  }
  /**
   * @internal
   * Analyze the given `value` to determine which data type is being animated.
   * Then, create an `Animated` node for that data type and make it our `node`.
   */
  ;

  _proto.setNodeWithValue = function setNodeWithValue(value) {
    if (value != null) {
      this.node = this._getNodeType(value).create(computeGoal(value));
    }
  }
  /**
   * @internal
   * Analyze the given `props` to determine which data type is being animated.
   * Then, create an `Animated` node for that data type and make it our `node`.
   * If we already have a `node`, do nothing but return the `{from, to}` range.
   */
  ;

  _proto.setNodeWithProps = function setNodeWithProps(props) {
    var range = this._getRange(props);

    if (!this.node) {
      this.setNodeWithValue(range.from != null ? range.from : range.to);
    }

    return range;
  }
  /** Return the `Animated` node constructor for a given value */
  ;

  _proto._getNodeType = function _getNodeType(value) {
    var parent = animated.isAnimationValue(value) ? value : null;
    var parentType = parent && parent.node && parent.node.constructor;

    if (!parent && shared.isFluidValue(value)) {
      value = value.get();
    }

    return parentType == animated.AnimatedString ? animated.AnimatedValue : parentType || (shared.is.arr(value) ? animated.AnimatedArray : shared.needsInterpolation(value) ? animated.AnimatedString : animated.AnimatedValue);
  }
  /** Pluck the `to` and `from` props */
  ;

  _proto._getRange = function _getRange(props) {
    var to = props.to,
        from = props.from;
    var key = this.key || '';
    return {
      to: !shared.is.obj(to) || shared.isFluidValue(to) ? to : to[key],
      from: !shared.is.obj(from) || shared.isFluidValue(from) ? from : from[key]
    };
  }
  /** Update this value's animation using the given props. */
  ;

  _proto._animate = function _animate(props) {
    var _this4 = this;

    // Ensure the initial value can be accessed by animated components.
    var range = this.setNodeWithProps(props);
    var timestamp = G.now();
    return scheduleProps(++this._lastAsyncId, props, this._state, function (props, resolve) {
      var to = props.to;

      if (shared.is.arr(to) || shared.is.fun(to)) {
        resolve(runAsync(to, props, _this4._state, function () {
          return _this4.get();
        }, function () {
          return _this4.is(PAUSED);
        }, _this4.start.bind(_this4), _this4.stop.bind(_this4)));
      } else if (props.cancel) {
        _this4.stop();

        resolve({
          value: _this4.get(),
          cancelled: true
        });
      } else {
        _this4._update(range, props, timestamp, resolve);
      }
    });
  }
  /** Update the internal `animation` object */
  ;

  _proto._update = function _update(_ref, props, timestamp, resolve) {
    var to = _ref.to,
        from = _ref.from;
    var defaultProps = this._defaultProps;
    /** Get the value of a prop, or its default value */

    var get = function get(prop) {
      return !shared.is.und(props[prop]) ? props[prop] : defaultProps[prop];
    };

    var onAnimate = get('onAnimate');

    if (onAnimate) {
      onAnimate(props, this);
    } // Cast from a partial type.


    var anim = this.animation;
    var timestamps = this._timestamps;
    /** Return true if our prop can be used. This only affects delayed props. */

    var diff = function diff(prop) {
      if (timestamp >= (timestamps[prop] || 0)) {
        timestamps[prop] = timestamp;
        return true;
      }

      return false;
    };

    var prevTo = anim.to,
        prevFrom = anim.from; // The "reverse" prop only affects one update.

    if (props.reverse) {
      var _ref2 = [from, to];
      to = _ref2[0];
      from = _ref2[1];
    }

    if (!shared.is.und(to) && diff('to')) {
      this._to(to);
    } else {
      to = prevTo;
    }

    if (!shared.is.und(from) && diff('from')) {
      anim.from = from;
    } else {
      from = anim.from;
    }

    if (shared.isFluidValue(from)) {
      from = from.get();
    }

    var reset = props.reset && !shared.is.und(from);
    var changed = !shared.is.und(to) && !shared.isEqual(to, prevTo);
    var parent = shared.isFluidValue(to) && to;
    /** The current value */

    var value = reset ? from : this.get();

    if (shared.is.und(from)) {
      from = value;
    }
    /** When true, this spring must be in the frameloop. */


    var started = !!parent || (changed || reset) && !shared.isEqual(value, to);
    /** The initial velocity before this `animate` call. */

    var lastVelocity = anim.config ? anim.config.velocity : 0; // The "config" prop either overwrites or merges into the existing config.

    var config = props.config;

    if (config || started || !anim.config) {
      var key = this.key || '';
      config = _extends({}, callProp(defaultProps.config, key), callProp(config, key));

      if (!started && canMergeConfigs(config, anim.config)) {
        Object.assign(anim.config, config);
      } else {
        anim.config = config = _extends({}, BASE_CONFIG, config);
      } // Derive "tension" and "friction" from "frequency" and "damping".


      if (!shared.is.und(config.frequency)) {
        var damping = shared.is.und(config.damping) ? 1 : config.damping;
        config.tension = Math.pow(config.frequency, 2) * config.mass;
        config.friction = damping * Math.sqrt(config.tension * config.mass) / 0.5;
      } // Cache the angular frequency in rad/ms


      config.w0 = Math.sqrt(config.tension / config.mass) / 1000;
    } else {
      config = anim.config;
    } // Always start animations with velocity.


    if (!started && (config.decay || !shared.is.und(to))) {
      started = !shared.isEqual(config.velocity, lastVelocity);
    } // Reset our internal `Animated` node if starting.


    var node = this.node;
    var nodeType;

    if (changed) {
      nodeType = this._getNodeType(to);

      if (nodeType !== node.constructor) {
        throw Error("Cannot animate to the given \"to\" prop, because the current value has a different type");
      }
    } else {
      nodeType = node.constructor;
    } // The final value of our animation, excluding the "to" value.
    // The "FrameLoop" decides our goal value when "parent" exists.


    var goal = parent ? null : computeGoal(to);

    if (nodeType == animated.AnimatedString) {
      from = 0;
      goal = 1;
    } // Ensure the current value equals the "from" value when reset
    // and when the "from" value is updated before the first animation.


    if (reset || this.is(CREATED) && !shared.is.und(anim.from) && !shared.isEqual(anim.from, prevFrom)) {
      node.setValue(value = from);
    } // Event props are replaced on every update.


    anim.onStart = get('onStart');
    anim.onChange = get('onChange'); // Update the default props.

    if (props.default) {
      shared.each(DEFAULT_PROPS, function (prop) {
        // Default props can only be null, an object, or a function.
        if (/function|object/.test(typeof props[prop])) {
          defaultProps[prop] = props[prop];
        }
      });
    }

    if (!started) {
      // Resolve the "animate" promise.
      return resolve({
        value: value,
        spring: this,
        finished: true
      });
    } // This must come *before* "fromValues" is set,
    // because it updates "node.lastPosition"


    this._reset();

    anim.values = node.getPayload();
    anim.toValues = parent ? null : shared.toArray(goal);
    anim.fromValues = anim.values.map(function (node) {
      return node.lastPosition;
    });
    anim.immediate = !(parent || shared.is.num(goal) || shared.is.arr(goal)) || !!matchProp(get('immediate'), this.key);
    var onRestQueue = anim.onRest; // The "onRest" prop is always first in the queue.

    anim.onRest = [get('onRest') || noop, resolve]; // Resolve the promise for unfinished animations.

    if (onRestQueue && onRestQueue.length > 1) {
      var result = {
        value: value,
        spring: this,
        cancelled: true
      }; // Skip the "onRest" prop, as the animation is still active.

      for (var i = 1; i < onRestQueue.length; i++) {
        onRestQueue[i](result);
      }
    }

    this._start();
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */
  ;

  _proto._to = function _to(value) {
    var anim = this.animation;

    if (shared.isFluidValue(anim.to)) {
      if (value == anim.to) return;
      anim.to.removeChild(this);
    }

    anim.to = value;

    if (shared.isFluidValue(value)) {
      value.addChild(this);
      this.priority = (value.priority || 0) + 1;
    } else {
      this.priority = 0;
    }
  }
  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */
  ;

  _proto._set = function _set(value) {
    if (shared.isFluidValue(value)) {
      value = value.get();
    }

    var node = this.node;

    if (node) {
      if (shared.isEqual(value, node.getValue())) {
        return false;
      }

      node.setValue(value);
    } else {
      this.setNodeWithValue(value);
    }

    return true;
  }
  /** Notify change observers */
  ;

  _proto._onChange = function _onChange(value, idle) {
    if (idle === void 0) {
      idle = false;
    }

    var anim = this.animation;

    if (!anim.changed && !idle) {
      anim.changed = true; // The "onStart" prop is called on the first change after entering the
      // frameloop, but never for immediate animations.

      if (anim.onStart) {
        anim.onStart(this);
      }
    }

    if (anim.onChange) {
      anim.onChange(value, this);
    }

    _AnimationValue.prototype._onChange.call(this, value, idle);
  };

  _proto._onPriorityChange = function _onPriorityChange(priority) {
    if (!this.idle) {
      // Re-enter the frameloop so our new priority is used.
      G.frameLoop.stop(this).start(this);
    }

    _AnimationValue.prototype._onPriorityChange.call(this, priority);
  }
  /** Reset our node, and the nodes of every descendant spring */
  ;

  _proto._reset = function _reset(goal) {
    if (goal === void 0) {
      goal = computeGoal(this.animation.to);
    }

    _AnimationValue.prototype._reset.call(this, goal);
  }
  /** Enter the frameloop */
  ;

  _proto._start = function _start() {
    if (this.idle) {
      this._phase = ACTIVE; // Animations without "onRest" cannot enter the frameloop.

      var anim = this.animation;

      if (anim.onRest) {
        anim.changed = false; // The "skipAnimation" global avoids the frameloop.

        if (G.skipAnimation) {
          this.finish(anim.to);
        } else {
          G.frameLoop.start(this);
        }
      } // Tell animatable children to enter the frameloop.


      shared.each(this._children, function (child) {
        if (child instanceof SpringValue) {
          child._start();
        }
      });
    }
  }
  /** Exit the frameloop and notify `onRest` listeners */
  ;

  _proto._stop = function _stop(finished) {
    if (finished === void 0) {
      finished = false;
    }

    if (!this.idle) {
      this._phase = IDLE; // Always let change observers know when a spring becomes idle.

      this._onChange(this.get(), true);

      var anim = this.animation;
      var onRestQueue = anim.onRest; // Animations without "onRest" never enter the frameloop.

      if (onRestQueue) {
        G.frameLoop.stop(this);
        shared.each(anim.values, function (node) {
          node.done = true;
        }); // Preserve the "onRest" prop between animations.

        anim.onRest = [onRestQueue[0]]; // Never call the "onRest" prop for immediate or no-op animations.

        if (anim.immediate || !anim.changed) {
          onRestQueue[0] = noop;
        }

        var result = {
          value: this.get(),
          spring: this,
          finished: finished
        };
        shared.each(onRestQueue, function (onRest) {
          return onRest(result);
        });
      }
    }
  };

  _createClass(SpringValue, [{
    key: "idle",
    get: function get() {
      return !this.is(ACTIVE);
    }
  }]);

  return SpringValue;
}(animated.AnimationValue); // TODO: makes this tree-shakeable

function checkDisposed(spring, name) {
  if (spring.is(DISPOSED)) {
    throw Error("Cannot call \"" + name + "\" of disposed \"" + spring.constructor.name + "\" object");
  }
} // Merge configs when the existence of "decay" or "duration" has not changed.


function canMergeConfigs(src, dest) {
  return !!dest && shared.is.und(src.decay) == shared.is.und(dest.decay) && shared.is.und(src.duration) == shared.is.und(dest.duration);
} // Compute the goal value, converting "red" to "rgba(255, 0, 0, 1)" in the process


function computeGoal(value) {
  return shared.is.arr(value) ? value.map(computeGoal) : shared.isFluidValue(value) ? computeGoal(value.get()) : shared.needsInterpolation(value) ? G.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}

var nextId = 1;
var lastAsyncId = 0;
var Controller =
/*#__PURE__*/
function () {
  function Controller(props) {
    this.id = nextId++;
    /** The values that changed in the last animation frame */

    this.frame = {};
    /** Fallback values for undefined props */

    this.defaultProps = {};
    /** The queue of pending props */

    this.queue = [];
    /** The current controller-only props (eg: `onFrame` and async state) */

    this._props = {};
    /** The spring values that manage their animations */

    this._springs = {};
    this._onChange = this._onChange.bind(this);
    this._onFrame = this._onFrame.bind(this);

    if (props) {
      props.default = true;
      this.start(props);
    }
  }
  /** Equals true when no springs are animating */


  var _proto = Controller.prototype;

  _proto.get = function get(key) {
    return this._springs[key];
  }
  /** Push an update onto the queue of each value. */
  ;

  _proto.update = function update(props) {
    if (props) this.queue.push(this._update(props));
    return this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */
  ;

  _proto.start =
  /*#__PURE__*/
  function () {
    var _start = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee(queue) {
      var _this = this;

      var promises, results;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (queue) {
                queue = shared.toArray(queue).map(function (props) {
                  return _this._update(props);
                });
              } else {
                queue = this.queue;
                this.queue = [];
              }

              promises = [];
              shared.each(queue, function (props) {
                var to = props.to,
                    onFrame = props.onFrame,
                    keys = props.keys;
                var asyncTo = (shared.is.arr(to) || shared.is.fun(to)) && to;

                if (asyncTo) {
                  props.to = undefined;
                }

                promises.push.apply(promises, keys.map(function (key) {
                  return _this._springs[key].start(props);
                }).concat([// Schedule controller-only props.
                scheduleProps(++lastAsyncId, props, _this._props, function (props, resolve) {
                  if (!props.cancel) {
                    // Never reuse "onFrame" from a previous update.
                    _this._props.onFrame = onFrame || _this.defaultProps.onFrame;

                    if (onFrame && props.default) {
                      _this.defaultProps.onFrame = onFrame;
                    }
                  } // Start, replace, or cancel the async animation.


                  if (asyncTo) {
                    resolve(runAsync(asyncTo, props, _this._props, _this._get.bind(_this), function () {
                      return false;
                    }, // TODO: add pausing to Controller
                    _this.start.bind(_this), _this.stop.bind(_this)));
                  } else {
                    resolve({
                      value: 0,
                      finished: !props.cancel
                    });
                  }
                })]));
              });
              _context.next = 5;
              return Promise.all(promises);

            case 5:
              results = _context.sent;
              return _context.abrupt("return", {
                value: this._get(),
                finished: results.every(function (result) {
                  return result.finished;
                })
              });

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function start(_x) {
      return _start.apply(this, arguments);
    }

    return start;
  }()
  /** Stop one animation, some animations, or all animations */
  ;

  _proto.stop = function stop(keys) {
    var _this2 = this;

    if (shared.is.und(keys)) {
      shared.each(this._springs, function (spring) {
        return spring.stop();
      });
    } else {
      shared.each(shared.toArray(keys), function (key) {
        return _this2._springs[key].stop();
      });
    }

    return this;
  }
  /** Restart every animation. */
  ;

  _proto.reset = function reset() {
    shared.each(this._springs, function (spring) {
      return spring.reset();
    }); // TODO: restart async "to" prop

    return this;
  }
  /** Destroy every spring in this controller */
  ;

  _proto.dispose = function dispose() {
    this._props.asyncTo = undefined;
    shared.each(this._springs, function (spring) {
      return spring.dispose();
    });
    this._springs = {};
  }
  /** Get the current value of every spring */
  ;

  _proto._get = function _get() {
    var values = {};
    shared.each(this._springs, function (spring, key) {
      values[key] = spring.get();
    });
    return values;
  }
  /** Create a spring for every given key, and ensure they have `Animated` nodes. */
  ;

  _proto._setSprings = function _setSprings(keys, from, to) {
    var _this3 = this;

    shared.each(keys, function (key) {
      if (!_this3._springs[key]) {
        var spring = _this3._springs[key] = new SpringValue(key);
        spring.addChild(_this3._onChange);
        spring.setNodeWithProps({
          from: from,
          to: to
        });
      }
    });
  }
  /** Prepare an update with the given props. */
  ;

  _proto._update = function _update(propsArg) {
    var props = interpolateTo(propsArg);
    var keys = props.keys = extractKeys(props, this._springs);
    var from = props.from,
        to = props.to; // Avoid sending async "to" prop to springs.

    if (shared.is.arr(to) || shared.is.fun(to)) {
      to = undefined;
    } // Create our springs and give them values.


    if (from || to) {
      this._setSprings(keys, from, to);
    }

    return props;
  }
  /** @internal Attached as an observer to every spring */
  ;

  _proto._onChange = function _onChange(value, spring) {
    if (this._props.onFrame) {
      this.frame[spring.key] = value;
      G.frameLoop.onFrame(this._onFrame);
    }
  }
  /** @internal Called at the end of every animation frame */
  ;

  _proto._onFrame = function _onFrame() {
    if (Object.keys(this.frame).length) {
      this._props.onFrame(this.frame);

      this.frame = {};
    }
  };

  _createClass(Controller, [{
    key: "idle",
    get: function get() {
      return !this._props.promise && Object.values(this._springs).every(function (s) {
        return s.idle;
      });
    }
    /** Get all existing `SpringValue` objects. This clones the internal store. */

  }, {
    key: "springs",
    get: function get() {
      return _extends({}, this._springs);
    }
  }]);

  return Controller;
}();
/** Determine which keys should receive an update */

function extractKeys(props, springs) {
  var keys = new Set();
  /** Collect keys with a defined value */

  var getDefinedKeys = function getDefinedKeys(obj) {
    return shared.each(obj, function (value, key) {
      if (!shared.is.und(value)) {
        keys.add(key);
      }
    });
  };

  var from = props.from,
      to = props.to;
  if (shared.is.obj(to)) getDefinedKeys(to);
  if (from) getDefinedKeys(from); // When neither "from" or "to" have a key with a defined value,
  // return the keys for every existing spring.

  return keys.size ? Array.from(keys) : Object.keys(springs);
}

/** @internal */

function useSprings(length, props, deps) {
  var propsFn = shared.is.fun(props) && props;

  if (propsFn && arguments.length < 3) {
    deps = []; // Skip updates after first render.
  } // The "ref" prop is taken from the props of the first spring only.
  // The ref is assumed to *never* change after the first render.


  var ref;
  var ctrls = useMemo(function () {
    return [];
  }, []);
  var updates = [];
  var prevLength = shared.usePrev(length) || 0;
  useMemo(function () {
    if (prevLength > length) {
      for (var i = length; i < prevLength; i++) {
        ctrls[i].dispose();
      }
    }

    ctrls.length = length;

    for (var _i = 0; _i < length; _i++) {
      var ctrl = ctrls[_i] || (ctrls[_i] = new Controller());
      var update = propsFn ? propsFn(_i, ctrl) : props[_i];

      if (update) {
        update.default = true;

        if (_i == 0 && update.ref) {
          ref = update.ref;
        }

        if (_i < prevLength) {
          updates[_i] = update;
        } else {
          // Update new controllers immediately, so their
          // spring values exist during first render.
          ctrl.update(update);
        }
      }
    }
  }, deps);
  var api = React.useMemo(function () {
    return {
      get controllers() {
        return ctrls;
      },

      update: function update(props) {
        shared.each(ctrls, function (ctrl, i) {
          ctrl.update(getProps(props, i, ctrl));
          if (!ref) ctrl.start();
        });
        return api;
      },
      start: function () {
        var _start = _asyncToGenerator(
        /*#__PURE__*/
        _regeneratorRuntime.mark(function _callee() {
          var results;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Promise.all(ctrls.map(function (ctrl) {
                    return ctrl.start();
                  }));

                case 2:
                  results = _context.sent;
                  return _context.abrupt("return", {
                    value: results.map(function (result) {
                      return result.value;
                    }),
                    finished: results.every(function (result) {
                      return result.finished;
                    })
                  });

                case 4:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function start() {
          return _start.apply(this, arguments);
        }

        return start;
      }(),
      stop: function stop(keys) {
        return shared.each(ctrls, function (ctrl) {
          return ctrl.stop(keys);
        });
      }
    };
  }, []);
  React.useImperativeHandle(ref, function () {
    return api;
  });
  shared.useIsomorphicLayoutEffect(function () {
    shared.each(updates, function (update, i) {
      return ctrls[i].update(update);
    });

    if (!ref) {
      shared.each(ctrls, function (ctrl) {
        return ctrl.start();
      });
    }
  }, deps);
  shared.useOnce(function () {
    return function () {
      shared.each(ctrls, function (ctrl) {
        return ctrl.dispose();
      });
    };
  });
  var values = ctrls.map(function (ctrl) {
    return ctrl.springs;
  });
  return propsFn || arguments.length == 3 ? [values, api.update, api.stop] : values;
}

/** @internal */

function useSpring(props, deps) {
  var isFn = shared.is.fun(props);

  var _useSprings = useSprings(1, isFn ? props : [props], deps),
      _useSprings$ = _useSprings[0],
      values = _useSprings$[0],
      update = _useSprings[1],
      stop = _useSprings[2];

  return isFn || arguments.length == 3 ? [values, update, stop] : values;
}

function useTrail(length, propsArg, deps) {
  var propsFn = shared.is.fun(propsArg) && propsArg;

  if (propsFn && arguments.length < 3) {
    deps = []; // Skip updates after first render.
  }

  var ctrls = [];
  var result = useSprings(length, function (i, ctrl) {
    ctrls[i] = ctrl;
    return getProps(propsArg, i, ctrl);
  }, deps);
  shared.useIsomorphicLayoutEffect(function () {
    var reverse = shared.is.obj(propsArg) && propsArg.reverse;

    for (var i = 0; i < ctrls.length; i++) {
      var parent = ctrls[i + (reverse ? 1 : -1)];
      if (parent) ctrls[i].update({
        to: parent.springs
      }).start();
    }
  }, deps);
  var update = result[1];

  result[1] = function (propsArg) {
    var reverse = shared.is.obj(propsArg) && propsArg.reverse;
    return update(function (i, ctrl) {
      var props = getProps(propsArg, i, ctrl);
      var parent = ctrls[i + (reverse ? 1 : -1)];
      if (parent) props.to = parent.springs;
      return props;
    });
  };

  return propsFn ? result : result[0];
}

/** This transition is being mounted */

var MOUNT = 0;
/** This transition is entering or has entered */

var ENTER = 1;
/** This transition had its animations updated */

var UPDATE = 2;
/** This transition will expire after animating */

var LEAVE = 3;

function getKeys(items, _ref) {
  var key = _ref.key,
      _ref$keys = _ref.keys,
      keys = _ref$keys === void 0 ? key : _ref$keys;
  return shared.is.und(keys) ? items : shared.is.fun(keys) ? items.map(keys) : shared.toArray(keys);
}

function useTransition(data, props, deps) {
  var ref = props.ref,
      reset = props.reset,
      sort = props.sort,
      _props$trail = props.trail,
      trail = _props$trail === void 0 ? 0 : _props$trail,
      _props$expires = props.expires,
      expires = _props$expires === void 0 ? Infinity : _props$expires; // Every item has its own transition.

  var items = shared.toArray(data);
  var transitions = []; // Keys help with reusing transitions between renders.
  // The `key` prop can be undefined (which means the items themselves are used
  // as keys), or a function (which maps each item to its key), or an array of
  // keys (which are assigned to each item by index).

  var keys = getKeys(items, props); // The "onRest" callbacks need a ref to the latest transitions.

  var usedTransitions = React.useRef(null);
  var prevTransitions = usedTransitions.current;
  shared.useIsomorphicLayoutEffect(function () {
    usedTransitions.current = transitions;
  }); // Destroy all transitions on dismount.

  shared.useOnce(function () {
    return function () {
      return shared.each(usedTransitions.current, function (t) {
        if (t.expiresBy != null) {
          clearTimeout(t.expirationId);
        }

        t.ctrl.dispose();
      });
    };
  }); // Map old indices to new indices.

  var reused = [];
  if (prevTransitions && !reset) shared.each(prevTransitions, function (t, i) {
    // Expired transitions are not rendered.
    if (t.expiresBy != null) {
      clearTimeout(t.expirationId);
    } else {
      i = reused[i] = keys.indexOf(t.key);
      if (~i) transitions[i] = t;
    }
  }); // Mount new items with fresh transitions.

  shared.each(items, function (item, i) {
    transitions[i] || (transitions[i] = {
      key: keys[i],
      item: item,
      phase: MOUNT,
      ctrl: new Controller()
    });
  }); // Update the item of any transition whose key still exists,
  // and ensure leaving transitions are rendered until they finish.

  if (reused.length) {
    var i = -1;
    shared.each(reused, function (keyIndex, prevIndex) {
      var t = prevTransitions[prevIndex];

      if (~keyIndex) {
        i = transitions.indexOf(t);
        transitions[i] = _extends({}, t, {
          item: items[keyIndex]
        });
      } else if (props.leave) {
        transitions.splice(++i, 0, t);
      }
    });
  }

  if (shared.is.fun(sort)) {
    transitions.sort(function (a, b) {
      return sort(a.item, b.item);
    });
  } // Track cumulative delay for the "trail" prop.


  var delay = -trail; // Expired transitions use this to dismount.

  var forceUpdate = shared.useForceUpdate();
  var defaultProps = {};
  shared.each(DEFAULT_PROPS, function (prop) {
    if (/function|object/.test(typeof props[prop])) {
      defaultProps[prop] = props[prop];
    }
  }); // Generate changes to apply in useEffect.

  var changes = new Map();
  shared.each(transitions, function (t, i) {
    var to;
    var from;
    var phase;

    if (t.phase == MOUNT) {
      to = props.enter;
      phase = ENTER; // The "initial" prop is only used on first render. It always overrides
      // the "from" prop when defined, and it makes "enter" instant when null.

      from = props.initial;

      if (shared.is.und(from) || prevTransitions && !reset) {
        from = props.from;
      }
    } else {
      var isLeave = keys.indexOf(t.key) < 0;

      if (t.phase < LEAVE) {
        if (isLeave) {
          to = props.leave;
          phase = LEAVE;
        } else if (to = props.update) {
          phase = UPDATE;
        } else return;
      } else if (!isLeave) {
        to = props.enter;
        phase = ENTER;
      } else return;
    } // The payload is used to update the spring props once the current render is committed.


    var payload = _extends({}, defaultProps, {
      // When "to" is a function, it can return (1) an array of "useSpring" props,
      // (2) an async function, or (3) an object with any "useSpring" props.
      to: to = callProp(to, t.item, i),
      from: callProp(from, t.item, i),
      delay: delay += trail,
      config: callProp(props.config || defaultProps.config, t.item, i)
    }, shared.is.obj(to) && interpolateTo(to));

    var onRest = payload.onRest;

    payload.onRest = function (result) {
      if (shared.is.fun(onRest)) {
        onRest(result);
      }

      if (t.phase == LEAVE && t.ctrl.idle) {
        t.expiresBy = G.now() + expires;

        if (expires <= 0) {
          forceUpdate();
        } else {
          // Postpone dismounts while other controllers are active.
          var _transitions = usedTransitions.current;

          if (_transitions.every(function (t) {
            return t.ctrl.idle;
          })) {
            forceUpdate();
          } // When `expires` is infinite, postpone dismount until next render.
          else if (expires < Infinity) {
              t.expirationId = setTimeout(forceUpdate, expires);
            }
        }
      }
    };

    var change = {
      phase: phase
    };
    changes.set(t, change); // To ensure all Animated nodes exist during render,
    // the payload must be applied immediately for new items.

    if (t.phase > MOUNT) {
      change.payload = payload;
    } else {
      t.ctrl.update(payload);
    }
  });
  var api = React.useMemo(function () {
    return {
      get controllers() {
        return usedTransitions.current.map(function (t) {
          return t.ctrl;
        });
      },

      update: function update(props) {
        shared.each(usedTransitions.current, function (t, i) {
          return t.ctrl.update(shared.is.fun(props) ? props(i, t.ctrl) : shared.is.arr(props) ? props[i] : props);
        });
        return api;
      },
      start: function () {
        var _start = _asyncToGenerator(
        /*#__PURE__*/
        _regeneratorRuntime.mark(function _callee() {
          var transitions, results;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  transitions = usedTransitions.current;
                  _context.next = 3;
                  return Promise.all(transitions.map(function (t) {
                    return t.ctrl.start();
                  }));

                case 3:
                  results = _context.sent;
                  return _context.abrupt("return", {
                    value: results.map(function (result) {
                      return result.value;
                    }),
                    finished: results.every(function (result) {
                      return result.finished;
                    })
                  });

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function start() {
          return _start.apply(this, arguments);
        }

        return start;
      }(),
      stop: function stop(keys) {
        return shared.each(usedTransitions.current, function (t) {
          return t.ctrl.stop(keys);
        });
      }
    };
  }, []);
  React.useImperativeHandle(ref, function () {
    return api;
  });
  shared.useIsomorphicLayoutEffect(function () {
    shared.each(changes, function (_ref2, t) {
      var phase = _ref2.phase,
          payload = _ref2.payload;
      t.phase = phase;
      if (payload) t.ctrl.update(payload);
      if (!ref) t.ctrl.start();
    });
  }, reset ? void 0 : deps);
  return function (render) {
    return transitions.map(function (t) {
      var elem = render(t.ctrl.springs, t.item, t);
      return elem && elem.type ? React__default.createElement(elem.type, Object.assign({}, elem.props, {
        key: shared.is.str(t.key) || shared.is.num(t.key) ? t.key : t.ctrl.id,
        ref: elem.ref
      })) : elem;
    });
  };
}

function Spring(_ref) {
  var children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  return children(useSpring(props));
}
function Trail(_ref2) {
  var items = _ref2.items,
      children = _ref2.children,
      props = _objectWithoutPropertiesLoose(_ref2, ["items", "children"]);

  var trails = useTrail(items.length, props);
  return items.map(function (item, index) {
    var result = children(item, index);
    return shared.is.fun(result) ? result(trails[index]) : result;
  });
}
function Transition(_ref3) {
  var items = _ref3.items,
      children = _ref3.children,
      props = _objectWithoutPropertiesLoose(_ref3, ["items", "children"]);

  return useTransition(items, props)(children);
}

/** Map the value of one or more dependencies */

var to = function to(source) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return new animated.Into(source, args);
};
/** @deprecated Use the `to` export instead */

var interpolate = function interpolate(source) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return deprecations.deprecateInterpolate(), new animated.Into(source, args);
};

var FrameLoop =
/*#__PURE__*/
function () {
  function FrameLoop(_temp) {
    var _this = this;

    var _ref = _temp === void 0 ? {} : _temp,
        update = _ref.update,
        requestFrame = _ref.requestFrame;

    /**
     * The animated springs
     */
    this.springs = [];
    /**
     * True when at least one spring is animating.
     */

    this.active = false;
    /** Equals true when a frame is being processed. */

    this.updating = false;
    /** Equals true when writing to native attributes. */

    this.writing = false; // These queues are swapped at the end of every frame,
    // after the current queue is drained.

    this._queues = [new Set(), new Set()];
    /** `onWrite` callbacks are flushed on every frame, after `onFrame` callbacks are flushed. */

    this._writes = new Set();

    this._requestFrame = // The global `requestAnimationFrame` must be dereferenced to avoid "Illegal invocation" errors
    requestFrame || function (fn) {
      return (0, G.requestAnimationFrame)(fn);
    };

    this.update = update && update.bind(this) || function (time) {
      if (!_this.active) {
        return false;
      }

      if (shared.is.und(time)) {
        time = G.performanceNow();
      }

      var dt = time - _this.lastTime;

      if (dt > 0) {
        // http://gafferongames.com/game-physics/fix-your-timestep/
        if (dt > 64) dt = 64;
        _this.updating = true;
        var springs = _this.springs;
        if (springs.length) [].concat(springs).forEach(function (spring) {
          spring.idle || _this.advance(dt, spring);
        }); // Notify frame listeners.

        var queues = _this._queues;
        var queue = queues[0];

        if (queue.size) {
          // Run and clear the queue.
          queue.forEach(function (onFrame) {
            return onFrame();
          });
          queue.clear(); // Swap the queues.

          queues[0] = queues[1];
          queues[1] = queue;
        }

        var writes = _this._writes;

        if (writes.size) {
          _this.writing = true;
          writes.forEach(function (write) {
            return write(time);
          });
          _this.writing = false;
          writes.clear();
        }

        _this.updating = false;

        if (!_this.springs.length) {
          return _this.active = false;
        }
      }

      _this.lastTime = time;

      _this._requestFrame(_this.update);

      return true;
    };
  }
  /**
   * Schedule a function to run at the end of the current frame,
   * after all springs have been updated.
   *
   * Pass `true` as the 2nd argument to run at the end of the **next** frame.
   */


  var _proto = FrameLoop.prototype;

  _proto.onFrame = function onFrame(cb, next) {
    this._queues[next && this.updating ? 1 : 0].add(cb);

    this._start();
  }
  /**
   * Schedule a function run at the end of the current frame,
   * after all `onFrame` callbacks have been called.
   *
   * Calling `onWrite` from inside an `onWrite` callback simply
   * calls the nested write immediately.
   */
  ;

  _proto.onWrite = function onWrite(cb) {
    if (this.writing) {
      cb(this.lastTime);
    } else {
      this._writes.add(cb);
    }
  }
  /**
   * Start animating the given spring.
   *
   * Beware: Never `start` the same spring twice (without `stop` between).
   */
  ;

  _proto.start = function start(spring) {
    var springs = this.springs;
    var i = springs.findIndex(function (s) {
      return s.priority > spring.priority;
    });
    if (i < 0) i = springs.length;
    springs.splice(i, 0, spring);

    this._start();
  };

  _proto._start = function _start() {
    if (!this.active) {
      this.active = true;
      this.lastTime = G.performanceNow();

      this._requestFrame(this.update);
    }
  }
  /**
   * Stop animating the given spring
   */
  ;

  _proto.stop = function stop(spring) {
    var springs = this.springs;
    var i = springs.indexOf(spring);
    if (~i) springs.splice(i, 1);
    return this;
  }
  /**
   * Advance an animation forward one frame.
   */
  ;

  _proto.advance = function advance(dt, spring) {
    var idle = true;
    var changed = false;
    var anim = spring.animation;
    var parent = shared.isFluidValue(anim.to) && anim.to;
    var payload = animated.isAnimationValue(parent) && parent.node.getPayload();
    anim.values.forEach(function (node, i) {
      if (node.done) return;
      var to = payload ? payload[i].lastPosition : parent ? shared.toArray(parent.get())[i] : anim.toValues[i]; // Parent springs must finish before their children can.

      var canFinish = !payload || payload[i].done; // Jump to end value for immediate animations.

      if (anim.immediate) {
        node.done = canFinish;

        if (node.setValue(to)) {
          changed = true;
        }

        return;
      }

      var config = anim.config; // Loose springs never move.

      if (config.tension == 0) {
        node.done = true;
        return;
      }

      var elapsed = node.elapsedTime += dt;
      var from = anim.fromValues[i];
      var v0 = node.v0 != null ? node.v0 : node.v0 = shared.is.arr(config.velocity) ? config.velocity[i] : config.velocity;
      var position = node.lastPosition;
      var velocity;
      var finished; // Duration easing

      if (!shared.is.und(config.duration)) {
        var p = config.progress;
        if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);
        position = from + config.easing(p) * (to - from);
        velocity = (position - node.lastPosition) / dt;
        finished = p == 1;
      } // Decay easing
      else if (config.decay) {
          var decay = config.decay === true ? 0.998 : config.decay;
          var e = Math.exp(-(1 - decay) * elapsed);
          position = from + v0 / (1 - decay) * (1 - e); // derivative of position

          velocity = v0 * e;
          finished = Math.abs(node.lastPosition - position) < 0.1;
          if (finished) to = position;
        } // Spring easing
        else {
            velocity = node.lastVelocity == null ? v0 : node.lastVelocity;
            /** The smallest distance from a value before being treated like said value. */

            var precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));
            /** The velocity at which movement is essentially none */

            var restVelocity = config.restVelocity || precision; // Bouncing is opt-in (not to be confused with overshooting)

            var bounceFactor = config.clamp ? 0 : config.bounce;
            var canBounce = !shared.is.und(bounceFactor);
            /** When `true`, the value is increasing over time */

            var isGrowing = from == to ? node.v0 > 0 : from < to;
            /** When `true`, the velocity is considered moving */

            var isMoving;
            /** When `true`, the velocity is being deflected or clamped */

            var isBouncing = false;
            var step = 0.05 / config.w0;
            var numSteps = Math.ceil(dt / step);

            for (var n = 0; n < numSteps; ++n) {
              isMoving = Math.abs(velocity) > restVelocity;

              if (!isMoving) {
                finished = Math.abs(to - position) <= precision;

                if (finished) {
                  break;
                }
              }

              if (canBounce) {
                isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.

                if (isBouncing) {
                  velocity = -velocity * bounceFactor;
                  position = to;
                }
              }

              var springForce = -config.tension * 0.000001 * (position - to);
              var dampingForce = -config.friction * 0.001 * velocity;
              var acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2

              velocity = velocity + acceleration * step; // pt/ms

              position = position + velocity * step;
            }
          }

      if (Number.isNaN(position)) {
        throw Error("Found NaN value while advancing \"" + spring.key + "\" animation");
      }

      if (finished && canFinish) {
        node.done = true;
      } else {
        idle = false;
      }

      node.lastVelocity = velocity;

      if (node.setValue(position, config.round)) {
        changed = true;
      }
    });
    spring.onFrame(idle, changed);
  };

  return FrameLoop;
}();

shared.Globals.assign({
  frameLoop: new FrameLoop(),
  createStringInterpolator: stringInterpolation.createStringInterpolator,
  applyAnimatedValues: function applyAnimatedValues() {
    return false;
  }
});
/** Advance all animations forward one frame */

var update = function update() {
  return shared.Globals.frameLoop.update();
};

Object.defineProperty(exports, 'Globals', {
  enumerable: true,
  get: function () {
    return shared.Globals;
  }
});
Object.defineProperty(exports, 'createInterpolator', {
  enumerable: true,
  get: function () {
    return shared.createInterpolator;
  }
});
Object.defineProperty(exports, 'isFluidValue', {
  enumerable: true,
  get: function () {
    return shared.isFluidValue;
  }
});
Object.defineProperty(exports, 'makeFluidValue', {
  enumerable: true,
  get: function () {
    return shared.makeFluidValue;
  }
});
Object.defineProperty(exports, 'AnimationValue', {
  enumerable: true,
  get: function () {
    return animated.AnimationValue;
  }
});
Object.defineProperty(exports, 'Into', {
  enumerable: true,
  get: function () {
    return animated.Into;
  }
});
Object.defineProperty(exports, 'isAnimationValue', {
  enumerable: true,
  get: function () {
    return animated.isAnimationValue;
  }
});
exports.Controller = Controller;
exports.FrameLoop = FrameLoop;
exports.Spring = Spring;
exports.SpringValue = SpringValue;
exports.Trail = Trail;
exports.Transition = Transition;
exports.config = config;
exports.interpolate = interpolate;
exports.to = to;
exports.update = update;
exports.useChain = useChain;
exports.useSpring = useSpring;
exports.useSprings = useSprings;
exports.useTrail = useTrail;
exports.useTransition = useTransition;
//# sourceMappingURL=index.cjs.js.map
