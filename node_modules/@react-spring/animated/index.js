import { defineHidden, FluidType, is, each, isFluidValue, createInterpolator, toArray, isEqual, Globals, needsInterpolation, useForceUpdate, useIsomorphicLayoutEffect } from '@react-spring/shared';
import _extends from '@babel/runtime/helpers/esm/extends';
import { deprecateInterpolate } from '@react-spring/shared/deprecations';
import { to, createAnimatedTransform, createAnimatedStyle, frameLoop, applyAnimatedValues, getComponentProps } from '@react-spring/shared/globals';
import { createInterpolator as createInterpolator$1, is as is$1 } from '@react-spring/shared';
import React, { forwardRef, useRef } from 'react';

const AnimatedType = '__$AnimatedType';
/** Returns true for `Animated` nodes. Returns false for `SpringValue` objects. */

const isAnimated = value => !!(value && value[AnimatedType]);
class Animated {
  constructor() {
    defineHidden(this, AnimatedType, 1);
  }
  /** Returns every animated number used by this node. */


  getPayload() {
    return this.payload || [];
  }

}
/** The `AnimatedProps` class sets this before initializing */

Animated.context = null;

const isAnimationValue = value => (value && value[FluidType]) == 2;
let nextId = 1;
/**
 * A kind of `FluidValue` that manages an `AnimatedValue` node.
 *
 * Its underlying value can be accessed and even observed.
 */

class AnimationValue {
  constructor(key) {
    this.key = key;
    this.id = nextId++;
    this._priority = 0;
    this._children = new Set();
    defineHidden(this, FluidType, 2);
  }
  /** @internal Controls the order in which animations are updated */


  get priority() {
    return this._priority;
  }

  set priority(priority) {
    if (this._priority != priority) {
      this._priority = priority;

      this._onPriorityChange(priority);
    }
  }
  /** Get the current value */


  get() {
    // The node doesn't exist until the first update, which normally isn't an
    // issue but it can be for tests.
    return this.node && this.node.getValue();
  }
  /** Create a spring that maps our value to another value */


  to() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return to(this, args);
  }
  /** @deprecated Use the `to` method instead. */


  interpolate() {
    deprecateInterpolate();

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return to(this, args);
  }
  /** @internal */


  addChild(child) {
    if (!this._children.size) this._attach();

    this._children.add(child);
  }
  /** @internal */


  removeChild(child) {
    this._children.delete(child);

    if (!this._children.size) this._detach();
  }
  /** @internal */


  onParentPriorityChange(priority, _parent) {
    // Assume we only have one parent.
    this.priority = priority + 1;
  }

  _attach() {}

  _detach() {}
  /** Notify observers of a change to our value */


  _onChange(value, idle) {
    if (idle === void 0) {
      idle = false;
    }

    // Clone "_children" so it can be safely mutated by the loop.
    for (const observer of Array.from(this._children)) {
      if (is.fun(observer)) {
        observer(value, this);
      } else {
        observer.onParentChange(value, idle, this);
      }
    }
  }
  /** Notify observers of a change to our priority */


  _onPriorityChange(priority) {
    each(this._children, observer => {
      if (!is.fun(observer)) {
        observer.onParentPriorityChange(priority, this);
      }
    });
  }
  /** Reset our node and the nodes of every descendant */


  _reset(goal) {
    this.node.reset(!this.idle, goal);
    each(this._children, observer => {
      if (isAnimationValue(observer)) {
        observer._reset(goal);
      }
    });
  }

}

/** An object containing `Animated` nodes */

class AnimatedObject extends Animated {
  constructor(source) {
    if (source === void 0) {
      source = null;
    }

    super();
    this.setValue(source);
  }

  getValue(animated) {
    if (!this.source) return null;
    const values = {};
    each(this.source, (source, key) => {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated);
      } else if (isFluidValue(source)) {
        values[key] = source.get();
      } else if (!animated) {
        values[key] = source;
      }
    });
    return values;
  }
  /** Replace the raw object data */


  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }

  reset(isActive, _goal) {
    if (this.payload) {
      each(this.payload, node => node.reset(isActive));
    }
  }
  /** Create a payload set. */


  _makePayload(source) {
    if (source) {
      const payload = new Set();
      each(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  /** Add to a payload set. */


  _addToPayload(source) {
    if (isFluidValue(source)) {
      if (Animated.context) {
        Animated.context.dependencies.add(source);
      }

      if (isAnimationValue(source)) {
        source = source.node;
      }
    }

    if (isAnimated(source)) {
      each(source.getPayload(), node => this.add(node));
    }
  }

}

class AnimatedStyle extends AnimatedObject {
  constructor(style) {
    super(style || null);
  }

  setValue(style) {
    super.setValue(style && style.transform && createAnimatedTransform ? _extends({}, style, {
      transform: createAnimatedTransform(style.transform)
    }) : style);
  }

}

/** An animated number or a native attribute value */

class AnimatedValue extends Animated {
  constructor(_value) {
    super();
    this._value = _value;
    this.done = true;

    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }

  static create(from, _to) {
    return new AnimatedValue(from);
  }

  getPayload() {
    return [this];
  }

  getValue() {
    return this._value;
  }
  /**
   * Set the current value and optionally round it.
   *
   * The `step` argument does nothing whenever it equals `undefined` or `0`.
   * It works with fractions and whole numbers. The best use case is (probably)
   * rounding to the pixel grid with a step of:
   *
   *      1 / window.devicePixelRatio
   */


  setValue(value, step) {
    if (is.num(value)) {
      this.lastPosition = value;

      if (step) {
        value = Math.round(value / step) * step;

        if (this.done) {
          this.lastPosition = value;
        }
      }
    }

    if (this._value === value) {
      return false;
    }

    this._value = value;
    return true;
  }

  reset(isActive, _goal) {
    this.done = false;

    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.lastPosition = this._value;
      if (!isActive) this.lastVelocity = null;
      this.v0 = null;
    }
  }

}

/**
 * `Into` springs are memoized interpolators that react to their dependencies.
 *  The memoized result is updated whenever a dependency changes.
 */

class Into extends AnimationValue {
  constructor(
  /** The source of input values */
  source, args) {
    super();
    this.source = source;
    this.calc = createInterpolator(...args);
    this.node = new AnimatedValue(this._compute());
  }

  get idle() {
    return this.node.done;
  }

  _compute() {
    const inputs = is.arr(this.source) ? this.source.map(node => node.get()) : toArray(this.source.get());
    return this.calc(...inputs);
  }

  _attach() {
    // Start observing our "source" once we have an observer.
    let priority = 0;
    each(toArray(this.source), source => {
      priority = Math.max(priority, (source.priority || 0) + 1);
      source.addChild(this);
    });
    this.priority = priority;
  }

  _detach() {
    // Stop observing our "source" once we have no observers.
    each(toArray(this.source), source => {
      source.removeChild(this);
    });
  }
  /** @internal */


  onParentChange(_value, idle) {
    const node = this.node;

    if (idle && !node.done) {
      // We're not idle until every source is idle.
      node.done = toArray(this.source).every(source => !isAnimationValue(source) || source.idle);
    } // TODO: only compute once per frame (note: we'll need to call "onParentChange")


    const value = this._compute();

    if (!isEqual(value, this.get())) {
      node.setValue(value);

      this._onChange(value, node.done);
    }
  }
  /** @internal */


  onParentPriorityChange(_priority) {
    // Set our priority to 1 + the highest parent.
    this.priority = toArray(this.source).reduce((max, source) => Math.max(max, (source.priority || 0) + 1), 0);
  }

}

Globals.assign({
  to: (source, args) => new Into(source, args),
  createAnimatedStyle: style => new AnimatedStyle(style)
});

class AnimatedString extends AnimatedValue {
  constructor(from, to) {
    super(0);
    this._string = null;
    this._toString = createInterpolator$1({
      output: [from, to]
    });
  }

  static create(from, to) {
    if (to === void 0) {
      to = from;
    }

    if (is$1.str(from) && is$1.str(to)) {
      return new AnimatedString(from, to);
    }

    throw TypeError('Expected "from" and "to" to be strings');
  }

  getValue() {
    let value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }

  setValue(value) {
    if (!is$1.num(value)) {
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }

    return true;
  }

  reset(isActive, goal) {
    if (goal) {
      this._toString = createInterpolator$1({
        output: [this.getValue(), goal]
      });
    }

    this._value = 0;
    super.reset(isActive);
  }

}

/** An array of animated nodes */

class AnimatedArray extends AnimatedObject {
  constructor(from, to) {
    super(null);
    super.setValue(this._makeAnimated(from, to));
  }

  static create(from, to) {
    return new AnimatedArray(from, to);
  }

  getValue() {
    return this.source.map(node => node.getValue());
  }

  setValue(newValue) {
    const payload = this.getPayload(); // Reuse the payload when lengths are equal.

    if (newValue && newValue.length == payload.length) {
      each(payload, (node, i) => node.setValue(newValue[i]));
    } else {
      // Remake the payload when length changes.
      this.source = this._makeAnimated(newValue);
      this.payload = this._makePayload(this.source);
    }
  }
  /** Convert the `from` and `to` values to an array of `Animated` nodes */


  _makeAnimated(from, to) {
    if (to === void 0) {
      to = from;
    }

    return from ? from.map((from, i) => (needsInterpolation(from) ? AnimatedString : AnimatedValue).create(from, to[i])) : [];
  }

}

class AnimatedProps extends AnimatedObject {
  constructor(update) {
    super(null);
    this.update = update;
    /** Equals true when a re-render is scheduled for "end of frame" */

    this.dirty = false;
  }

  setValue(props, context) {
    if (!props) return; // The constructor passes null.

    if (context) {
      Animated.context = context;
    }

    super.setValue(props.style && createAnimatedStyle ? _extends({}, props, {
      style: createAnimatedStyle(props.style)
    }) : props);
    Animated.context = null;
  }
  /** @internal */


  onParentChange() {
    if (!this.dirty) {
      this.dirty = true;
      frameLoop.onFrame(() => {
        this.dirty = false;
        this.update();
      });
    }
  }
  /** @internal */


  onParentPriorityChange() {}

}

const cacheKey = Symbol.for('AnimatedComponent');
const withAnimated = Component => is.str(Component) ? createAnimatedComponent(Component) : Component[cacheKey] || (Component[cacheKey] = createAnimatedComponent(Component));

const createAnimatedComponent = Component => forwardRef((rawProps, ref) => {
  const instanceRef = useRef(null);
  const hasInstance = // Function components must use "forwardRef" to avoid being
  // re-rendered on every animation frame.
  !is.fun(Component) || Component.prototype.isReactComponent;
  const forceUpdate = useForceUpdate();
  const props = new AnimatedProps(() => {
    const instance = instanceRef.current;

    if (hasInstance && !instance) {
      return; // The wrapped component forgot to forward its ref.
    }

    const didUpdate = instance ? applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.

    if (didUpdate === false) {
      forceUpdate();
    }
  });
  const dependencies = new Set();
  props.setValue(rawProps, {
    dependencies
  });
  useIsomorphicLayoutEffect(() => {
    each(dependencies, dep => dep.addChild(props));
    return () => each(dependencies, dep => dep.removeChild(props));
  });
  return React.createElement(Component, Object.assign({}, getComponentProps(props.getValue()), {
    ref: hasInstance && (value => {
      instanceRef.current = updateRef(ref, value);
    })
  }));
});

function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref)) ref(value);else ref.current = value;
  }

  return value;
}
/**
 * Pass the given components to `withAnimated` and add the newly animated
 * components to `withAnimated` as properties.
 */


const extendAnimated = (withAnimated, components, lowercase) => {
  components.forEach(Component => {
    let key = getDisplayName(Component);

    if (lowercase) {
      key = key[0].toLowerCase() + key.slice(1);
    }

    withAnimated[key] = withAnimated(Component);
  });
  return withAnimated;
};

const getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

export { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedStyle, AnimatedType, AnimatedValue, AnimationValue, Into, extendAnimated, isAnimated, isAnimationValue, withAnimated };
//# sourceMappingURL=index.js.map
