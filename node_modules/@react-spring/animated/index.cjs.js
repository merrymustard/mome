'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var shared = require('@react-spring/shared');
var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var _createClass = _interopDefault(require('@babel/runtime/helpers/createClass'));
var deprecations = require('@react-spring/shared/deprecations');
var G = require('@react-spring/shared/globals');
var shared$1 = require('@react-spring/shared/index.js');
var _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));
var React = require('react');
var React__default = _interopDefault(React);

var AnimatedType = '__$AnimatedType';
/** Returns true for `Animated` nodes. Returns false for `SpringValue` objects. */

var isAnimated = function isAnimated(value) {
  return !!(value && value[AnimatedType]);
};
var Animated =
/*#__PURE__*/
function () {
  function Animated() {
    shared.defineHidden(this, AnimatedType, 1);
  }
  /** Returns every animated number used by this node. */


  var _proto = Animated.prototype;

  _proto.getPayload = function getPayload() {
    return this.payload || [];
  };

  return Animated;
}();
/** The `AnimatedProps` class sets this before initializing */

Animated.context = null;

var isAnimationValue = function isAnimationValue(value) {
  return (value && value[shared.FluidType]) == 2;
};
var nextId = 1;
/**
 * A kind of `FluidValue` that manages an `AnimatedValue` node.
 *
 * Its underlying value can be accessed and even observed.
 */

var AnimationValue =
/*#__PURE__*/
function () {
  function AnimationValue(key) {
    this.key = key;
    this.id = nextId++;
    this._priority = 0;
    this._children = new Set();
    shared.defineHidden(this, shared.FluidType, 2);
  }
  /** @internal Controls the order in which animations are updated */


  var _proto = AnimationValue.prototype;

  /** Get the current value */
  _proto.get = function get() {
    // The node doesn't exist until the first update, which normally isn't an
    // issue but it can be for tests.
    return this.node && this.node.getValue();
  }
  /** Create a spring that maps our value to another value */
  ;

  _proto.to = function to() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return G.to(this, args);
  }
  /** @deprecated Use the `to` method instead. */
  ;

  _proto.interpolate = function interpolate() {
    deprecations.deprecateInterpolate();

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return G.to(this, args);
  }
  /** @internal */
  ;

  _proto.addChild = function addChild(child) {
    if (!this._children.size) this._attach();

    this._children.add(child);
  }
  /** @internal */
  ;

  _proto.removeChild = function removeChild(child) {
    this._children.delete(child);

    if (!this._children.size) this._detach();
  }
  /** @internal */
  ;

  _proto.onParentPriorityChange = function onParentPriorityChange(priority, _parent) {
    // Assume we only have one parent.
    this.priority = priority + 1;
  };

  _proto._attach = function _attach() {};

  _proto._detach = function _detach() {}
  /** Notify observers of a change to our value */
  ;

  _proto._onChange = function _onChange(value, idle) {
    if (idle === void 0) {
      idle = false;
    }

    // Clone "_children" so it can be safely mutated by the loop.
    for (var _i = 0, _Array$from = Array.from(this._children); _i < _Array$from.length; _i++) {
      var observer = _Array$from[_i];

      if (shared.is.fun(observer)) {
        observer(value, this);
      } else {
        observer.onParentChange(value, idle, this);
      }
    }
  }
  /** Notify observers of a change to our priority */
  ;

  _proto._onPriorityChange = function _onPriorityChange(priority) {
    var _this = this;

    shared.each(this._children, function (observer) {
      if (!shared.is.fun(observer)) {
        observer.onParentPriorityChange(priority, _this);
      }
    });
  }
  /** Reset our node and the nodes of every descendant */
  ;

  _proto._reset = function _reset(goal) {
    this.node.reset(!this.idle, goal);
    shared.each(this._children, function (observer) {
      if (isAnimationValue(observer)) {
        observer._reset(goal);
      }
    });
  };

  _createClass(AnimationValue, [{
    key: "priority",
    get: function get() {
      return this._priority;
    },
    set: function set(priority) {
      if (this._priority != priority) {
        this._priority = priority;

        this._onPriorityChange(priority);
      }
    }
  }]);

  return AnimationValue;
}();

/** An object containing `Animated` nodes */

var AnimatedObject =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedObject, _Animated);

  function AnimatedObject(source) {
    var _this;

    if (source === void 0) {
      source = null;
    }

    _this = _Animated.call(this) || this;

    _this.setValue(source);

    return _this;
  }

  var _proto = AnimatedObject.prototype;

  _proto.getValue = function getValue(animated) {
    if (!this.source) return null;
    var values = {};
    shared.each(this.source, function (source, key) {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated);
      } else if (shared.isFluidValue(source)) {
        values[key] = source.get();
      } else if (!animated) {
        values[key] = source;
      }
    });
    return values;
  }
  /** Replace the raw object data */
  ;

  _proto.setValue = function setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  };

  _proto.reset = function reset(isActive, _goal) {
    if (this.payload) {
      shared.each(this.payload, function (node) {
        return node.reset(isActive);
      });
    }
  }
  /** Create a payload set. */
  ;

  _proto._makePayload = function _makePayload(source) {
    if (source) {
      var payload = new Set();
      shared.each(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  /** Add to a payload set. */
  ;

  _proto._addToPayload = function _addToPayload(source) {
    var _this2 = this;

    if (shared.isFluidValue(source)) {
      if (Animated.context) {
        Animated.context.dependencies.add(source);
      }

      if (isAnimationValue(source)) {
        source = source.node;
      }
    }

    if (isAnimated(source)) {
      shared.each(source.getPayload(), function (node) {
        return _this2.add(node);
      });
    }
  };

  return AnimatedObject;
}(Animated);

var AnimatedStyle =
/*#__PURE__*/
function (_AnimatedObject) {
  _inheritsLoose(AnimatedStyle, _AnimatedObject);

  function AnimatedStyle(style) {
    return _AnimatedObject.call(this, style || null) || this;
  }

  var _proto = AnimatedStyle.prototype;

  _proto.setValue = function setValue(style) {
    _AnimatedObject.prototype.setValue.call(this, style && style.transform && G.createAnimatedTransform ? _extends({}, style, {
      transform: G.createAnimatedTransform(style.transform)
    }) : style);
  };

  return AnimatedStyle;
}(AnimatedObject);

/** An animated number or a native attribute value */

var AnimatedValue =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedValue, _Animated);

  function AnimatedValue(_value) {
    var _this;

    _this = _Animated.call(this) || this;
    _this._value = _value;
    _this.done = true;

    if (shared.is.num(_this._value)) {
      _this.lastPosition = _this._value;
    }

    return _this;
  }

  AnimatedValue.create = function create(from, _to) {
    return new AnimatedValue(from);
  };

  var _proto = AnimatedValue.prototype;

  _proto.getPayload = function getPayload() {
    return [this];
  };

  _proto.getValue = function getValue() {
    return this._value;
  }
  /**
   * Set the current value and optionally round it.
   *
   * The `step` argument does nothing whenever it equals `undefined` or `0`.
   * It works with fractions and whole numbers. The best use case is (probably)
   * rounding to the pixel grid with a step of:
   *
   *      1 / window.devicePixelRatio
   */
  ;

  _proto.setValue = function setValue(value, step) {
    if (shared.is.num(value)) {
      this.lastPosition = value;

      if (step) {
        value = Math.round(value / step) * step;

        if (this.done) {
          this.lastPosition = value;
        }
      }
    }

    if (this._value === value) {
      return false;
    }

    this._value = value;
    return true;
  };

  _proto.reset = function reset(isActive, _goal) {
    this.done = false;

    if (shared.is.num(this._value)) {
      this.elapsedTime = 0;
      this.lastPosition = this._value;
      if (!isActive) this.lastVelocity = null;
      this.v0 = null;
    }
  };

  return AnimatedValue;
}(Animated);

/**
 * `Into` springs are memoized interpolators that react to their dependencies.
 *  The memoized result is updated whenever a dependency changes.
 */

var Into =
/*#__PURE__*/
function (_AnimationValue) {
  _inheritsLoose(Into, _AnimationValue);

  function Into(
  /** The source of input values */
  source, args) {
    var _this;

    _this = _AnimationValue.call(this) || this;
    _this.source = source;
    _this.calc = shared.createInterpolator.apply(void 0, args);
    _this.node = new AnimatedValue(_this._compute());
    return _this;
  }

  var _proto = Into.prototype;

  _proto._compute = function _compute() {
    var inputs = shared.is.arr(this.source) ? this.source.map(function (node) {
      return node.get();
    }) : shared.toArray(this.source.get());
    return this.calc.apply(this, inputs);
  };

  _proto._attach = function _attach() {
    var _this2 = this;

    // Start observing our "source" once we have an observer.
    var priority = 0;
    shared.each(shared.toArray(this.source), function (source) {
      priority = Math.max(priority, (source.priority || 0) + 1);
      source.addChild(_this2);
    });
    this.priority = priority;
  };

  _proto._detach = function _detach() {
    var _this3 = this;

    // Stop observing our "source" once we have no observers.
    shared.each(shared.toArray(this.source), function (source) {
      source.removeChild(_this3);
    });
  }
  /** @internal */
  ;

  _proto.onParentChange = function onParentChange(_value, idle) {
    var node = this.node;

    if (idle && !node.done) {
      // We're not idle until every source is idle.
      node.done = shared.toArray(this.source).every(function (source) {
        return !isAnimationValue(source) || source.idle;
      });
    } // TODO: only compute once per frame (note: we'll need to call "onParentChange")


    var value = this._compute();

    if (!shared.isEqual(value, this.get())) {
      node.setValue(value);

      this._onChange(value, node.done);
    }
  }
  /** @internal */
  ;

  _proto.onParentPriorityChange = function onParentPriorityChange(_priority) {
    // Set our priority to 1 + the highest parent.
    this.priority = shared.toArray(this.source).reduce(function (max, source) {
      return Math.max(max, (source.priority || 0) + 1);
    }, 0);
  };

  _createClass(Into, [{
    key: "idle",
    get: function get() {
      return this.node.done;
    }
  }]);

  return Into;
}(AnimationValue);

shared.Globals.assign({
  to: function to(source, args) {
    return new Into(source, args);
  },
  createAnimatedStyle: function createAnimatedStyle(style) {
    return new AnimatedStyle(style);
  }
});

var AnimatedString =
/*#__PURE__*/
function (_AnimatedValue) {
  _inheritsLoose(AnimatedString, _AnimatedValue);

  function AnimatedString(from, to) {
    var _this;

    _this = _AnimatedValue.call(this, 0) || this;
    _this._string = null;
    _this._toString = shared$1.createInterpolator({
      output: [from, to]
    });
    return _this;
  }

  AnimatedString.create = function create(from, to) {
    if (to === void 0) {
      to = from;
    }

    if (shared$1.is.str(from) && shared$1.is.str(to)) {
      return new AnimatedString(from, to);
    }

    throw TypeError('Expected "from" and "to" to be strings');
  };

  var _proto = AnimatedString.prototype;

  _proto.getValue = function getValue() {
    var value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  };

  _proto.setValue = function setValue(value) {
    if (!shared$1.is.num(value)) {
      this._string = value;
      this._value = 1;
    } else if (_AnimatedValue.prototype.setValue.call(this, value)) {
      this._string = null;
    } else {
      return false;
    }

    return true;
  };

  _proto.reset = function reset(isActive, goal) {
    if (goal) {
      this._toString = shared$1.createInterpolator({
        output: [this.getValue(), goal]
      });
    }

    this._value = 0;

    _AnimatedValue.prototype.reset.call(this, isActive);
  };

  return AnimatedString;
}(AnimatedValue);

/** An array of animated nodes */

var AnimatedArray =
/*#__PURE__*/
function (_AnimatedObject) {
  _inheritsLoose(AnimatedArray, _AnimatedObject);

  function AnimatedArray(from, to) {
    var _this;

    _this = _AnimatedObject.call(this, null) || this;

    _AnimatedObject.prototype.setValue.call(_assertThisInitialized(_this), _this._makeAnimated(from, to));

    return _this;
  }

  AnimatedArray.create = function create(from, to) {
    return new AnimatedArray(from, to);
  };

  var _proto = AnimatedArray.prototype;

  _proto.getValue = function getValue() {
    return this.source.map(function (node) {
      return node.getValue();
    });
  };

  _proto.setValue = function setValue(newValue) {
    var payload = this.getPayload(); // Reuse the payload when lengths are equal.

    if (newValue && newValue.length == payload.length) {
      shared.each(payload, function (node, i) {
        return node.setValue(newValue[i]);
      });
    } else {
      // Remake the payload when length changes.
      this.source = this._makeAnimated(newValue);
      this.payload = this._makePayload(this.source);
    }
  }
  /** Convert the `from` and `to` values to an array of `Animated` nodes */
  ;

  _proto._makeAnimated = function _makeAnimated(from, to) {
    if (to === void 0) {
      to = from;
    }

    return from ? from.map(function (from, i) {
      return (shared.needsInterpolation(from) ? AnimatedString : AnimatedValue).create(from, to[i]);
    }) : [];
  };

  return AnimatedArray;
}(AnimatedObject);

var AnimatedProps =
/*#__PURE__*/
function (_AnimatedObject) {
  _inheritsLoose(AnimatedProps, _AnimatedObject);

  function AnimatedProps(update) {
    var _this;

    _this = _AnimatedObject.call(this, null) || this;
    _this.update = update;
    /** Equals true when a re-render is scheduled for "end of frame" */

    _this.dirty = false;
    return _this;
  }

  var _proto = AnimatedProps.prototype;

  _proto.setValue = function setValue(props, context) {
    if (!props) return; // The constructor passes null.

    if (context) {
      Animated.context = context;
    }

    _AnimatedObject.prototype.setValue.call(this, props.style && G.createAnimatedStyle ? _extends({}, props, {
      style: G.createAnimatedStyle(props.style)
    }) : props);

    Animated.context = null;
  }
  /** @internal */
  ;

  _proto.onParentChange = function onParentChange() {
    var _this2 = this;

    if (!this.dirty) {
      this.dirty = true;
      G.frameLoop.onFrame(function () {
        _this2.dirty = false;

        _this2.update();
      });
    }
  }
  /** @internal */
  ;

  _proto.onParentPriorityChange = function onParentPriorityChange() {};

  return AnimatedProps;
}(AnimatedObject);

var cacheKey = Symbol.for('AnimatedComponent');
var withAnimated = function withAnimated(Component) {
  return shared.is.str(Component) ? createAnimatedComponent(Component) : Component[cacheKey] || (Component[cacheKey] = createAnimatedComponent(Component));
};

var createAnimatedComponent = function createAnimatedComponent(Component) {
  return React.forwardRef(function (rawProps, ref) {
    var instanceRef = React.useRef(null);
    var hasInstance = // Function components must use "forwardRef" to avoid being
    // re-rendered on every animation frame.
    !shared.is.fun(Component) || Component.prototype.isReactComponent;
    var forceUpdate = shared.useForceUpdate();
    var props = new AnimatedProps(function () {
      var instance = instanceRef.current;

      if (hasInstance && !instance) {
        return; // The wrapped component forgot to forward its ref.
      }

      var didUpdate = instance ? G.applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.

      if (didUpdate === false) {
        forceUpdate();
      }
    });
    var dependencies = new Set();
    props.setValue(rawProps, {
      dependencies: dependencies
    });
    shared.useIsomorphicLayoutEffect(function () {
      shared.each(dependencies, function (dep) {
        return dep.addChild(props);
      });
      return function () {
        return shared.each(dependencies, function (dep) {
          return dep.removeChild(props);
        });
      };
    });
    return React__default.createElement(Component, Object.assign({}, G.getComponentProps(props.getValue()), {
      ref: hasInstance && function (value) {
        instanceRef.current = updateRef(ref, value);
      }
    }));
  });
};

function updateRef(ref, value) {
  if (ref) {
    if (shared.is.fun(ref)) ref(value);else ref.current = value;
  }

  return value;
}
/**
 * Pass the given components to `withAnimated` and add the newly animated
 * components to `withAnimated` as properties.
 */


var extendAnimated = function extendAnimated(withAnimated, components, lowercase) {
  components.forEach(function (Component) {
    var key = getDisplayName(Component);

    if (lowercase) {
      key = key[0].toLowerCase() + key.slice(1);
    }

    withAnimated[key] = withAnimated(Component);
  });
  return withAnimated;
};

var getDisplayName = function getDisplayName(arg) {
  return shared.is.str(arg) ? arg : arg && shared.is.str(arg.displayName) ? arg.displayName : shared.is.fun(arg) && arg.name || null;
};

exports.Animated = Animated;
exports.AnimatedArray = AnimatedArray;
exports.AnimatedObject = AnimatedObject;
exports.AnimatedProps = AnimatedProps;
exports.AnimatedString = AnimatedString;
exports.AnimatedStyle = AnimatedStyle;
exports.AnimatedType = AnimatedType;
exports.AnimatedValue = AnimatedValue;
exports.AnimationValue = AnimationValue;
exports.Into = Into;
exports.extendAnimated = extendAnimated;
exports.isAnimated = isAnimated;
exports.isAnimationValue = isAnimationValue;
exports.withAnimated = withAnimated;
//# sourceMappingURL=index.cjs.js.map
