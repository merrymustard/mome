import { FluidValue, Indexable, FluidObserver, InterpolatorArgs as InterpolatorArgs$1, ElementType } from '@react-spring/shared';
import { FluidObserver as FluidObserver$1, OneOrMore, FluidValue as FluidValue$1, InterpolatorFn, InterpolatorArgs } from '@react-spring/shared/types';

/** An animated number or a native attribute value */
declare class AnimatedValue<T = any> extends Animated {
    protected _value: T;
    done: boolean;
    elapsedTime: number;
    lastPosition: number;
    lastVelocity?: number | null;
    v0?: number | null;
    constructor(_value: T);
    static create<T>(from: T, _to?: T | null): AnimatedValue<T>;
    getPayload(): Payload;
    getValue(): T;
    /**
     * Set the current value and optionally round it.
     *
     * The `step` argument does nothing whenever it equals `undefined` or `0`.
     * It works with fractions and whole numbers. The best use case is (probably)
     * rounding to the pixel grid with a step of:
     *
     *      1 / window.devicePixelRatio
     */
    setValue(value: T, step?: number): boolean;
    reset(isActive?: boolean, _goal?: T): void;
}

declare const AnimatedType = "__$AnimatedType";
/** Returns true for `Animated` nodes. Returns false for `SpringValue` objects. */
declare const isAnimated: (value: any) => value is Animated<any>;
declare abstract class Animated<T = any> {
    constructor();
    /** The cache of animated numbers */
    protected payload?: Payload;
    /** Returns every value of the node. Pass true for only the animated values. */
    abstract getValue(animated?: boolean): T;
    /** Returns every animated number used by this node. */
    getPayload(): Payload;
    /** The `AnimatedProps` class sets this before initializing */
    static context: TreeContext | null;
}
declare type Payload = readonly AnimatedValue[];
declare type TreeContext = {
    dependencies: Set<FluidValue>;
};

declare type Value = string | number;
declare class AnimatedString extends AnimatedValue<Value> {
    protected _value: number;
    protected _string: string | null;
    protected _toString: (input: number) => string;
    constructor(from: string, to: string);
    static create<T>(from: T, to?: T | null): AnimatedValue<T>;
    getValue(): string;
    setValue(value: Value): boolean;
    reset(isActive?: boolean, goal?: string): void;
}

declare type Source = Indexable | null;
/** An object containing `Animated` nodes */
declare class AnimatedObject extends Animated {
    protected source: Source;
    constructor(source?: Source);
    getValue(animated?: boolean): Source;
    /** Replace the raw object data */
    setValue(source: Source): void;
    reset(isActive?: boolean, _goal?: Indexable): void;
    /** Create a payload set. */
    protected _makePayload(source: Source): AnimatedValue<any>[] | undefined;
    /** Add to a payload set. */
    protected _addToPayload(this: Set<AnimatedValue>, source: any): void;
}

declare type Value$1 = number | string;
declare type Source$1 = AnimatedValue<Value$1>[];
/** An array of animated nodes */
declare class AnimatedArray<T extends ReadonlyArray<Value$1> = Value$1[]> extends AnimatedObject {
    protected source: Source$1;
    constructor(from: T, to?: T);
    static create<T extends ReadonlyArray<Value$1>>(from: T, to?: T): AnimatedArray<T>;
    getValue(): T;
    setValue(newValue: T | null): void;
    /** Convert the `from` and `to` values to an array of `Animated` nodes */
    protected _makeAnimated(from: T | null, to?: T): AnimatedValue<string | number>[];
}

declare type Props = object & {
    style?: any;
};
declare class AnimatedProps extends AnimatedObject implements FluidObserver {
    update: () => void;
    /** Equals true when a re-render is scheduled for "end of frame" */
    dirty: boolean;
    constructor(update: () => void);
    setValue(props: Props | null, context?: TreeContext): void;
    /** @internal */
    onParentChange(): void;
    /** @internal */
    onParentPriorityChange(): void;
}

declare type Style = object & {
    transform?: any;
};
declare class AnimatedStyle extends AnimatedObject {
    constructor(style?: Style);
    setValue(style: Style | null): void;
}

/**
 * `Into` springs are memoized interpolators that react to their dependencies.
 *  The memoized result is updated whenever a dependency changes.
 */
declare class Into<In = any, Out = any> extends AnimationValue<Out> implements FluidObserver$1 {
    /** The source of input values */
    readonly source: OneOrMore<FluidValue$1>;
    /** @internal */
    readonly node: AnimatedValue<Out>;
    /** The function that maps inputs values to output */
    readonly calc: InterpolatorFn<In, Out>;
    constructor(
    /** The source of input values */
    source: OneOrMore<FluidValue$1>, args: InterpolatorArgs<In, Out>);
    readonly idle: boolean;
    protected _compute(): Out;
    protected _attach(): void;
    protected _detach(): void;
    /** @internal */
    onParentChange(_value: any, idle: boolean): void;
    /** @internal */
    onParentPriorityChange(_priority: number): void;
}

declare const isAnimationValue: (value: any) => value is AnimationValue<any>;
/** Called whenever an `AnimationValue` is changed */
declare type OnChange<T = unknown> = (value: T, source: AnimationValue<T>) => void;
/** An object or function that observes an `AnimationValue` */
declare type AnimationObserver<T = unknown> = FluidObserver<T> | OnChange<T>;
/**
 * A kind of `FluidValue` that manages an `AnimatedValue` node.
 *
 * Its underlying value can be accessed and even observed.
 */
declare abstract class AnimationValue<T = any> implements FluidValue<T>, FluidObserver {
    readonly key?: string | undefined;
    readonly id: number;
    abstract idle: boolean;
    abstract node: AnimatedValue<T> | (T extends ReadonlyArray<any> ? AnimatedArray<T> : never) | undefined;
    protected _priority: number;
    protected _children: Set<AnimationObserver<T>>;
    constructor(key?: string | undefined);
    /** @internal Controls the order in which animations are updated */
    priority: number;
    /** Get the current value */
    get(): T;
    /** Create a spring that maps our value to another value */
    to<Out>(...args: InterpolatorArgs$1<T, Out>): Into<T, Out>;
    /** @deprecated Use the `to` method instead. */
    interpolate<Out>(...args: InterpolatorArgs$1<T, Out>): Into<T, Out>;
    /** @internal */
    addChild(child: AnimationObserver<T>): void;
    /** @internal */
    removeChild(child: AnimationObserver<T>): void;
    /** @internal */
    abstract onParentChange(value: T, idle: boolean, parent: FluidValue): void;
    /** @internal */
    onParentPriorityChange(priority: number, _parent: FluidValue): void;
    protected _attach(): void;
    protected _detach(): void;
    /** Notify observers of a change to our value */
    protected _onChange(value: T, idle?: boolean): void;
    /** Notify observers of a change to our priority */
    protected _onPriorityChange(priority: number): void;
    /** Reset our node and the nodes of every descendant */
    protected _reset(goal?: T): void;
}

declare type AnimatableComponent = string | Exclude<ElementType, string>;
declare type WithAnimated = {
    (Component: AnimatableComponent): any;
    [key: string]: any;
};
declare const withAnimated: WithAnimated;
/**
 * Pass the given components to `withAnimated` and add the newly animated
 * components to `withAnimated` as properties.
 */
declare const extendAnimated: (withAnimated: WithAnimated, components: AnimatableComponent[], lowercase?: boolean | undefined) => any;

export { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedStyle, AnimatedType, AnimatedValue, AnimationObserver, AnimationValue, Into, OnChange, Payload, TreeContext, extendAnimated, isAnimated, isAnimationValue, withAnimated };
